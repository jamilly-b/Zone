<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/MainActivity.kt" />
              <option name="originalContent" value="package com.pdm.zone&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.navigation.compose.rememberNavController&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.pdm.zone.data.SessionManager&#10;import com.pdm.zone.ui.nav.MainDrawer&#10;import com.pdm.zone.ui.nav.BottomNavBar&#10;import com.pdm.zone.ui.nav.BottomNavItem&#10;import com.pdm.zone.ui.nav.MainDrawer&#10;import com.pdm.zone.ui.nav.MainNavHost&#10;import com.pdm.zone.ui.screens.login.LoginActivity&#10;import com.pdm.zone.ui.theme.ZoneTheme&#10;&#10;class MainActivity : ComponentActivity() {&#10;    @OptIn(ExperimentalMaterial3Api::class)&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;&#10;        val currentUser = FirebaseAuth.getInstance().currentUser&#10;&#10;        if (currentUser == null) {&#10;            startActivity(Intent(this, LoginActivity::class.java))&#10;            finish()&#10;            return&#10;        }&#10;&#10;        setContent {&#10;            var isUserLoaded by remember { mutableStateOf(false) }&#10;&#10;            // Carrega os dados do usuário quando entrar na tela&#10;            LaunchedEffect(Unit) {&#10;                SessionManager.loadUserAfterLogin(currentUser.uid)&#10;                isUserLoaded = true&#10;            }&#10;&#10;            // Enquanto não carregar os dados, mostra uma tela de loading&#10;            if (!isUserLoaded) {&#10;                ZoneTheme {&#10;                    Box(modifier = Modifier.fillMaxSize()) {&#10;                        CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))&#10;                    }&#10;                }&#10;            } else {&#10;                val navController = rememberNavController()&#10;                ZoneTheme {&#10;                    Scaffold(&#10;                        bottomBar = {&#10;                            val items = listOf(&#10;                                BottomNavItem.HomeButton,&#10;                                BottomNavItem.ListButton,&#10;                                BottomNavItem.ProfileButton,&#10;                            )&#10;                            BottomNavBar(navController = navController, items = items)&#10;                        },&#10;                        floatingActionButton = {&#10;                            FloatingActionButton(onClick = {&#10;                                navController.navigate(&quot;eventRegister&quot;)&#10;                            }) {&#10;                                Icon(Icons.Default.Add, contentDescription = &quot;Adicionar&quot;)&#10;                            }&#10;                        }&#10;                    ) { innerPadding -&gt;&#10;                        Box(modifier = Modifier.padding(innerPadding)) {&#10;                            MainNavHost(navController = navController)&#10;                        }&#10;                    }                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.pdm.zone&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.navigation.compose.rememberNavController&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.pdm.zone.data.SessionManager&#10;import com.pdm.zone.ui.nav.MainDrawer&#10;import com.pdm.zone.ui.nav.BottomNavBar&#10;import com.pdm.zone.ui.nav.BottomNavItem&#10;import com.pdm.zone.ui.nav.MainDrawer&#10;import com.pdm.zone.ui.nav.MainNavHost&#10;import com.pdm.zone.ui.screens.login.LoginActivity&#10;import com.pdm.zone.ui.theme.ZoneTheme&#10;&#10;class MainActivity : ComponentActivity() {&#10;    @OptIn(ExperimentalMaterial3Api::class)&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;&#10;        val currentUser = FirebaseAuth.getInstance().currentUser&#10;&#10;        if (currentUser == null) {&#10;            startActivity(Intent(this, LoginActivity::class.java))&#10;            finish()&#10;            return&#10;        }&#10;&#10;        setContent {&#10;            var isUserLoaded by remember { mutableStateOf(false) }&#10;&#10;            // Carrega os dados do usuário quando entrar na tela&#10;            LaunchedEffect(Unit) {&#10;                SessionManager.loadUserAfterLogin(currentUser.uid)&#10;                isUserLoaded = true&#10;            }&#10;&#10;            // Enquanto não carregar os dados, mostra uma tela de loading&#10;            if (!isUserLoaded) {&#10;                ZoneTheme {&#10;                    Box(modifier = Modifier.fillMaxSize()) {&#10;                        CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))&#10;                    }&#10;                }&#10;            } else {&#10;                val navController = rememberNavController()&#10;                ZoneTheme {&#10;                    Scaffold(&#10;                        bottomBar = {&#10;                            val items = listOf(&#10;                                BottomNavItem.HomeButton,&#10;                                BottomNavItem.SearchButton, // novo item de pesquisa&#10;                                BottomNavItem.ListButton,&#10;                                BottomNavItem.ProfileButton,&#10;                            )&#10;                            BottomNavBar(navController = navController, items = items)&#10;                        },&#10;                        floatingActionButton = {&#10;                            FloatingActionButton(onClick = {&#10;                                navController.navigate(&quot;eventRegister&quot;)&#10;                            }) {&#10;                                Icon(Icons.Default.Add, contentDescription = &quot;Adicionar&quot;)&#10;                            }&#10;                        }&#10;                    ) { innerPadding -&gt;&#10;                        Box(modifier = Modifier.padding(innerPadding)) {&#10;                            MainNavHost(navController = navController)&#10;                        }&#10;                    }                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/data/model/Event.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/data/model/Event.kt" />
              <option name="originalContent" value="package com.pdm.zone.data.model&#10;&#10;import com.google.firebase.firestore.DocumentId&#10;import com.google.firebase.firestore.ServerTimestamp&#10;import java.util.Date&#10;&#10;data class Event(&#10;    @DocumentId&#10;    var id: String = &quot;&quot;,&#10;    var title: String = &quot;&quot;,&#10;    var description: String = &quot;&quot;,&#10;    var location: String = &quot;&quot;,&#10;    var category: EventCategory = EventCategory.FESTAS,&#10;    var imageUrl: String? = null,&#10;    var creatorId: String = &quot;&quot;,&#10;    var creatorUsername: String = &quot;&quot;,&#10;&#10;    // Campos de data e hora&#10;    @ServerTimestamp&#10;    var eventDate: Date? = null,&#10;    var startTime: String? = null,&#10;    var endTime: String? = null,&#10;&#10;    var attendees: List&lt;String&gt; = emptyList(),&#10;    var interestedUsers: List&lt;String&gt; = emptyList()&#10;) {&#10;    constructor() : this(&#10;        id = &quot;&quot;,&#10;        title = &quot;&quot;,&#10;        description = &quot;&quot;,&#10;        location = &quot;&quot;,&#10;        category = EventCategory.FESTAS,&#10;        imageUrl = null,&#10;        creatorId = &quot;&quot;,&#10;        creatorUsername = &quot;&quot;,&#10;        eventDate = null,&#10;        startTime = null,&#10;        endTime = null,&#10;        attendees = emptyList(),&#10;        interestedUsers = emptyList()&#10;    )&#10;&#10;    // Propriedade para contagem de confirmados&#10;    val confirmedCount: Int&#10;        get() = attendees.size&#10;&#10;    // Propriedade para contagem de interessados&#10;    val interestedCount: Int&#10;        get() = interestedUsers.size&#10;&#10;    // Getters para compatibilidade com Firestore&#10;    @Suppress(&quot;unused&quot;)&#10;    fun getConfirmedCount(): Int {&#10;        return attendees.size&#10;    }&#10;&#10;    @Suppress(&quot;unused&quot;)&#10;    fun getInterestedCount(): Int {&#10;        return interestedUsers.size&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.pdm.zone.data.model&#10;&#10;import com.google.firebase.firestore.DocumentId&#10;import com.google.firebase.firestore.Exclude&#10;import com.google.firebase.firestore.PropertyName&#10;import com.google.firebase.firestore.ServerTimestamp&#10;import java.util.Date&#10;&#10;data class Event(&#10;    @DocumentId&#10;    var id: String = &quot;&quot;,&#10;    var title: String = &quot;&quot;,&#10;    var description: String = &quot;&quot;,&#10;    var location: String = &quot;&quot;,&#10;    var category: EventCategory = EventCategory.FESTAS,&#10;    var imageUrl: String? = null,&#10;    var creatorId: String = &quot;&quot;,&#10;    var creatorUsername: String = &quot;&quot;,&#10;&#10;    // Campos de data e hora&#10;    @ServerTimestamp&#10;    var eventDate: Date? = null,&#10;    var startTime: String? = null,&#10;    var endTime: String? = null,&#10;&#10;    var attendees: List&lt;String&gt; = emptyList(),&#10;    var interestedUsers: List&lt;String&gt; = emptyList(),&#10;&#10;    // Adicionamos estas propriedades com PropertyName para que o Firestore as reconheça&#10;    // mesmo sendo campos calculados no lado do cliente&#10;    @get:PropertyName(&quot;confirmedCount&quot;)&#10;    @PropertyName(&quot;confirmedCount&quot;)&#10;    var _confirmedCount: Int = 0,&#10;&#10;    @get:PropertyName(&quot;interestedCount&quot;)&#10;    @PropertyName(&quot;interestedCount&quot;)&#10;    var _interestedCount: Int = 0&#10;) {&#10;    constructor() : this(&#10;        id = &quot;&quot;,&#10;        title = &quot;&quot;,&#10;        description = &quot;&quot;,&#10;        location = &quot;&quot;,&#10;        category = EventCategory.FESTAS,&#10;        imageUrl = null,&#10;        creatorId = &quot;&quot;,&#10;        creatorUsername = &quot;&quot;,&#10;        eventDate = null,&#10;        startTime = null,&#10;        endTime = null,&#10;        attendees = emptyList(),&#10;        interestedUsers = emptyList()&#10;    )&#10;&#10;    // Propriedades calculadas&#10;    @get:Exclude  // Excluir do Firestore, pois usamos os campos _confirmedCount e _interestedCount para serialização&#10;    val confirmedCount: Int&#10;        get() = attendees.size&#10;&#10;    @get:Exclude  // Excluir do Firestore, pois usamos os campos _interestedCount e _interestedCount para serialização&#10;    val interestedCount: Int&#10;        get() = interestedUsers.size&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/components/CompactEventCard.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/components/CompactEventCard.kt" />
              <option name="updatedContent" value="package com.pdm.zone.ui.components&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.LocationOn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import coil.compose.AsyncImage&#10;import coil.request.ImageRequest&#10;import com.pdm.zone.R&#10;import com.pdm.zone.data.model.Event&#10;import com.pdm.zone.ui.theme.Primary&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;/**&#10; * Uma versão compacta do card de evento que exibe a imagem à esquerda e informações à direita&#10; * Usado nas telas de Eventos Confirmados e Eventos Criados pelo usuário&#10; */&#10;@Composable&#10;fun CompactEventCard(&#10;    event: Event,&#10;    onCardClick: (Event) -&gt; Unit = {}&#10;) {&#10;    val dateFormatter = remember { SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale(&quot;pt&quot;, &quot;BR&quot;)) }&#10;    &#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 8.dp, horizontal = 16.dp),&#10;        shape = RoundedCornerShape(8.dp),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp),&#10;        onClick = { onCardClick(event) }&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(8.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Imagem do evento&#10;            AsyncImage(&#10;                model = ImageRequest.Builder(LocalContext.current)&#10;                    .data(event.imageUrl)&#10;                    .crossfade(true)&#10;                    .build(),&#10;                placeholder = painterResource(R.drawable.placeholder_event),&#10;                contentDescription = event.title,&#10;                contentScale = ContentScale.Crop,&#10;                modifier = Modifier&#10;                    .size(100.dp)&#10;                    .clip(RoundedCornerShape(8.dp))&#10;            )&#10;&#10;            // Detalhes do evento&#10;            Column(&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .padding(start = 12.dp)&#10;            ) {&#10;                // Título&#10;                Text(&#10;                    text = event.title,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = Primary,&#10;                    fontWeight = FontWeight.Bold,&#10;                    maxLines = 2,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;&#10;                // Local&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    modifier = Modifier.padding(top = 4.dp)&#10;                ) {&#10;                    Icon(&#10;                        Icons.Default.LocationOn,&#10;                        contentDescription = &quot;Local&quot;,&#10;                        tint = Color.Gray,&#10;                        modifier = Modifier.size(16.dp)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(4.dp))&#10;                    Text(&#10;                        text = event.location,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = Color.Gray,&#10;                        maxLines = 1,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;                }&#10;&#10;                // Data&#10;                event.eventDate?.let { date -&gt;&#10;                    Row(&#10;                        verticalAlignment = Alignment.CenterVertically,&#10;                        modifier = Modifier.padding(top = 4.dp)&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;Data:&quot;,&#10;                            style = MaterialTheme.typography.bodySmall,&#10;                            fontWeight = FontWeight.Bold,&#10;                            color = Color.Gray&#10;                        )&#10;                        Spacer(modifier = Modifier.width(4.dp))&#10;                        Text(&#10;                            text = dateFormatter.format(date),&#10;                            style = MaterialTheme.typography.bodySmall,&#10;                            color = Color.Gray&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Horário&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    modifier = Modifier.padding(top = 4.dp)&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Horário:&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = Color.Gray&#10;                    )&#10;                    Spacer(modifier = Modifier.width(4.dp))&#10;                    Text(&#10;                        text = &quot;${event.startTime ?: &quot;--:--&quot;} - ${event.endTime ?: &quot;--:--&quot;}&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = Color.Gray&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/components/EventCard.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/components/EventCard.kt" />
              <option name="originalContent" value="package com.pdm.zone.ui.components&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.LocationOn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil.compose.AsyncImage&#10;import coil.request.ImageRequest&#10;import com.pdm.zone.R&#10;import com.pdm.zone.data.model.Event&#10;import com.pdm.zone.ui.theme.Primary&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;@Composable&#10;fun EventCard(&#10;    event: Event,&#10;    onCardClick: (Event) -&gt; Unit = {}&#10;) {&#10;    val dateFormatter = remember { SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale(&quot;pt&quot;, &quot;BR&quot;)) }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 8.dp, horizontal = 16.dp),&#10;        shape = RoundedCornerShape(8.dp),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp),&#10;        onClick = { onCardClick(event) }&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(8.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Imagem do evento&#10;            AsyncImage(&#10;                model = ImageRequest.Builder(LocalContext.current)&#10;                    .data(event.imageUrl)&#10;                    .crossfade(true)&#10;                    .build(),&#10;                placeholder = painterResource(R.drawable.placeholder_event),&#10;                contentDescription = event.title,&#10;                contentScale = ContentScale.Crop,&#10;                modifier = Modifier&#10;                    .size(100.dp)&#10;                    .clip(RoundedCornerShape(8.dp))&#10;            )&#10;&#10;            // Detalhes do evento&#10;            Column(&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .padding(start = 12.dp)&#10;            ) {&#10;                // Título&#10;                Text(&#10;                    text = event.title,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = Primary,&#10;                    fontWeight = FontWeight.Bold,&#10;                    maxLines = 2,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;&#10;                // Local&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    modifier = Modifier.padding(top = 4.dp)&#10;                ) {&#10;                    Icon(&#10;                        Icons.Default.LocationOn,&#10;                        contentDescription = &quot;Local&quot;,&#10;                        tint = Color.Gray,&#10;                        modifier = Modifier.size(16.dp)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(4.dp))&#10;                    Text(&#10;                        text = event.location,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = Color.Gray,&#10;                        maxLines = 1,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;                }&#10;&#10;                // Data&#10;                event.eventDate?.let { date -&gt;&#10;                    Row(&#10;                        verticalAlignment = Alignment.CenterVertically,&#10;                        modifier = Modifier.padding(top = 4.dp)&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;Data:&quot;,&#10;                            style = MaterialTheme.typography.bodySmall,&#10;                            fontWeight = FontWeight.Bold,&#10;                            color = Color.Gray&#10;                        )&#10;                        Spacer(modifier = Modifier.width(4.dp))&#10;                        Text(&#10;                            text = dateFormatter.format(date),&#10;                            style = MaterialTheme.typography.bodySmall,&#10;                            color = Color.Gray&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Horário&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    modifier = Modifier.padding(top = 4.dp)&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Horário:&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = Color.Gray&#10;                    )&#10;                    Spacer(modifier = Modifier.width(4.dp))&#10;                    Text(&#10;                        text = &quot;${event.startTime ?: &quot;--:--&quot;} - ${event.endTime ?: &quot;--:--&quot;}&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = Color.Gray&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// Função auxiliar para formatação de data e hora (mantida para compatibilidade)&#10;private fun formatEventDateTime(event: Event): String {&#10;    val dateFormat = SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale.getDefault())&#10;    val date = event.eventDate?.let { dateFormat.format(it) } ?: &quot;Data não definida&quot;&#10;    return date&#10;}" />
              <option name="updatedContent" value="package com.pdm.zone.ui.components&#13;&#10;&#13;&#10;import androidx.compose.foundation.layout.*&#13;&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#13;&#10;import androidx.compose.material.icons.Icons&#13;&#10;import androidx.compose.material.icons.filled.LocationOn&#13;&#10;import androidx.compose.material3.*&#13;&#10;import androidx.compose.runtime.Composable&#13;&#10;import androidx.compose.runtime.remember&#13;&#10;import androidx.compose.ui.Alignment&#13;&#10;import androidx.compose.ui.Modifier&#13;&#10;import androidx.compose.ui.draw.clip&#13;&#10;import androidx.compose.ui.graphics.Color&#13;&#10;import androidx.compose.ui.layout.ContentScale&#13;&#10;import androidx.compose.ui.platform.LocalContext&#13;&#10;import androidx.compose.ui.res.painterResource&#13;&#10;import androidx.compose.ui.text.font.FontWeight&#13;&#10;import androidx.compose.ui.text.style.TextOverflow&#13;&#10;import androidx.compose.ui.unit.dp&#13;&#10;import androidx.compose.ui.unit.sp&#13;&#10;import coil.compose.AsyncImage&#13;&#10;import coil.request.ImageRequest&#13;&#10;import com.pdm.zone.R&#13;&#10;import com.pdm.zone.data.model.Event&#13;&#10;import com.pdm.zone.ui.theme.Primary&#13;&#10;import com.pdm.zone.ui.theme.Secondary&#13;&#10;import java.text.SimpleDateFormat&#13;&#10;import java.util.*&#13;&#10;&#13;&#10;@Composable&#13;&#10;fun EventCard(&#13;&#10;    event: Event,&#13;&#10;    onCardClick: (Event) -&gt; Unit = {}&#13;&#10;) {&#13;&#10;    Card(&#13;&#10;        modifier = Modifier&#13;&#10;            .fillMaxWidth()&#13;&#10;            .wrapContentHeight(),&#13;&#10;        shape = RoundedCornerShape(15.dp),&#13;&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 0.dp),&#13;&#10;        colors = CardDefaults.cardColors(&#13;&#10;            containerColor = Color.Transparent&#13;&#10;        ),&#13;&#10;        onClick = { onCardClick(event) }&#13;&#10;    ) {&#13;&#10;        Column(&#13;&#10;            modifier = Modifier&#13;&#10;                .fillMaxWidth()&#13;&#10;                .padding(12.dp)&#13;&#10;        ) {&#13;&#10;&#13;&#10;            AsyncImage(&#13;&#10;                model = ImageRequest.Builder(LocalContext.current)&#13;&#10;                    .data(event.imageUrl)&#13;&#10;                    .crossfade(true)&#13;&#10;                    .build(),&#13;&#10;                placeholder = painterResource(R.drawable.placeholder_event),&#13;&#10;                contentDescription = event.title,&#13;&#10;                modifier = Modifier&#13;&#10;                    .fillMaxWidth()&#13;&#10;                    .height(200.dp)&#13;&#10;                    .clip(RoundedCornerShape(12.dp)),&#13;&#10;                contentScale = ContentScale.Crop&#13;&#10;            )&#13;&#10;&#13;&#10;            Spacer(modifier = Modifier.height(8.dp))&#13;&#10;&#13;&#10;            Text(&#13;&#10;                text = event.title,&#13;&#10;                fontSize = 18.sp,&#13;&#10;                fontWeight = FontWeight.Bold,&#13;&#10;                color = Primary,&#13;&#10;                maxLines = 2,&#13;&#10;                overflow = TextOverflow.Ellipsis&#13;&#10;            )&#13;&#10;&#13;&#10;            Row(&#13;&#10;                modifier = Modifier.fillMaxWidth(),&#13;&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#13;&#10;                verticalAlignment = Alignment.CenterVertically&#13;&#10;            ) {&#13;&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#13;&#10;                    Icon(&#13;&#10;                        Icons.Default.LocationOn,&#13;&#10;                        contentDescription = &quot;Localização&quot;,&#13;&#10;                        tint = Color.Gray,&#13;&#10;                        modifier = Modifier.size(16.dp)&#13;&#10;                    )&#13;&#10;                    Spacer(modifier = Modifier.width(4.dp))&#13;&#10;                    Text(&#13;&#10;                        text = event.location,&#13;&#10;                        fontSize = 12.sp,&#13;&#10;                        color = Secondary&#13;&#10;                    )&#13;&#10;                }&#13;&#10;&#13;&#10;                Text(&#13;&#10;                    text = formatEventDateTime(event),&#13;&#10;                    fontSize = 14.sp,&#13;&#10;                    color = Secondary,&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;// Função auxiliar para formatação de data e hora&#13;&#10;private fun formatEventDateTime(event: Event): String {&#13;&#10;    val dateFormat = SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale.getDefault())&#13;&#10;    val date = event.eventDate?.let { dateFormat.format(it) } ?: &quot;Data não definida&quot;&#13;&#10;    return date&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/nav/BottomNavItem.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/nav/BottomNavItem.kt" />
              <option name="originalContent" value="package com.pdm.zone.ui.nav&#10;&#10;import android.net.http.SslCertificate.restoreState&#10;import android.net.http.SslCertificate.saveState&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Favorite&#10;import androidx.compose.material.icons.filled.Home&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.NavigationBar&#10;import androidx.compose.material3.NavigationBarItem&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.unit.sp&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;import com.pdm.zone.ui.theme.Primary&#10;import kotlinx.serialization.Serializable&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import com.google.firebase.Firebase&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.firestore&#10;import com.pdm.zone.data.SessionManager&#10;&#10;sealed interface Route {&#10;    @Serializable&#10;    data object Home : Route&#10;    @Serializable&#10;    data object List : Route&#10;    @Serializable&#10;    data object Profile : Route&#10;}&#10;&#10;sealed class BottomNavItem(&#10;    val title: String,&#10;    val icon: ImageVector,&#10;    val route: Route&#10;) {&#10;    data object HomeButton :&#10;        BottomNavItem(&quot;Início&quot;, Icons.Default.Home, Route.Home)&#10;&#10;    data object ListButton :&#10;        BottomNavItem(&quot;Próximos eventos&quot;, Icons.Default.Favorite, Route.List)&#10;&#10;    data object ProfileButton :&#10;        BottomNavItem(&quot;Perfil&quot;, Icons.Default.Person, Route.Profile)&#10;}&#10;&#10;@Composable&#10;fun BottomNavBar(&#10;    navController: NavHostController,&#10;    items: List&lt;BottomNavItem&gt;&#10;    // 1. Removido o parâmetro 'currentUserId', que não é mais necessário&#10;) {&#10;    // 2. Usando o SessionManager como única fonte para o usuário logado.&#10;    val currentUser by SessionManager.currentUser.collectAsState()&#10;&#10;    NavigationBar(contentColor = Primary) {&#10;        val navBackStackEntry by navController.currentBackStackEntryAsState()&#10;        val currentRoute = navBackStackEntry?.destination?.route&#10;&#10;        // 3. O LaunchedEffect antigo foi completamente REMOVIDO daqui.&#10;&#10;        items.forEach { item -&gt;&#10;            NavigationBarItem(&#10;                icon = { Icon(imageVector = item.icon, contentDescription = item.title) },&#10;                label = { Text(text = item.title, fontSize = 12.sp) },&#10;                alwaysShowLabel = true,&#10;                selected = when (item) {&#10;                    // Compara a rota atual com a rota de perfil, usando o username do SessionManager&#10;                    is BottomNavItem.ProfileButton -&gt; currentRoute == &quot;profile/${currentUser?.username}&quot;&#10;                    // Compara outras rotas pelo seu nome de classe qualificado&#10;                    else -&gt; currentRoute == item.route::class.qualifiedName&#10;                },&#10;                // 4. Lógica de clique TOTALMENTE CORRIGIDA&#10;                onClick = {&#10;                    when (item.route) {&#10;                        is Route.Profile -&gt; {&#10;                            // Ação para o perfil: só navega se tiver um username&#10;                            currentUser?.username?.let { username -&gt;&#10;                                navController.navigate(&quot;profile/$username&quot;) {&#10;                                    // Comportamento padrão para itens da bottom bar&#10;                                    popUpTo(navController.graph.startDestinationId) {&#10;                                        saveState = true&#10;                                    }&#10;                                    launchSingleTop = true&#10;                                    restoreState = true&#10;                                }&#10;                            }&#10;                        }&#10;                        else -&gt; {&#10;                            // Ação para outros itens (Home, List)&#10;                            navController.navigate(item.route) {&#10;                                // Comportamento padrão para itens da bottom bar&#10;                                popUpTo(navController.graph.startDestinationId) {&#10;                                    saveState = true&#10;                                }&#10;                                launchSingleTop = true&#10;                                restoreState = true&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.pdm.zone.ui.nav&#10;&#10;import android.net.http.SslCertificate.restoreState&#10;import android.net.http.SslCertificate.saveState&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Favorite&#10;import androidx.compose.material.icons.filled.Home&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material.icons.filled.Search&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.NavigationBar&#10;import androidx.compose.material3.NavigationBarItem&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.unit.sp&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;import com.pdm.zone.ui.theme.Primary&#10;import kotlinx.serialization.Serializable&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import com.google.firebase.Firebase&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.firestore&#10;import com.pdm.zone.data.SessionManager&#10;&#10;sealed interface Route {&#10;    @Serializable&#10;    data object Home : Route&#10;    @Serializable&#10;    data object List : Route&#10;    @Serializable&#10;    data object Profile : Route&#10;    @Serializable&#10;    data object Search : Route // nova rota de pesquisa&#10;}&#10;&#10;sealed class BottomNavItem(&#10;    val title: String,&#10;    val icon: ImageVector,&#10;    val route: Route&#10;) {&#10;    data object HomeButton :&#10;        BottomNavItem(&quot;Início&quot;, Icons.Default.Home, Route.Home)&#10;&#10;    data object SearchButton :&#10;        BottomNavItem(&quot;Pesquisar&quot;, Icons.Default.Search, Route.Search) // novo botão&#10;&#10;    data object ListButton :&#10;        BottomNavItem(&quot;Próximos eventos&quot;, Icons.Default.Favorite, Route.List)&#10;&#10;    data object ProfileButton :&#10;        BottomNavItem(&quot;Perfil&quot;, Icons.Default.Person, Route.Profile)&#10;}&#10;&#10;@Composable&#10;fun BottomNavBar(&#10;    navController: NavHostController,&#10;    items: List&lt;BottomNavItem&gt;&#10;    // 1. Removido o parâmetro 'currentUserId', que não é mais necessário&#10;) {&#10;    // 2. Usando o SessionManager como única fonte para o usuário logado.&#10;    val currentUser by SessionManager.currentUser.collectAsState()&#10;&#10;    NavigationBar(contentColor = Primary) {&#10;        val navBackStackEntry by navController.currentBackStackEntryAsState()&#10;        val currentRoute = navBackStackEntry?.destination?.route&#10;&#10;        // 3. O LaunchedEffect antigo foi completamente REMOVIDO daqui.&#10;&#10;        items.forEach { item -&gt;&#10;            NavigationBarItem(&#10;                icon = { Icon(imageVector = item.icon, contentDescription = item.title) },&#10;                label = { Text(text = item.title, fontSize = 12.sp) },&#10;                alwaysShowLabel = true,&#10;                selected = when (item) {&#10;                    // Compara a rota atual com a rota de perfil, usando o username do SessionManager&#10;                    is BottomNavItem.ProfileButton -&gt; currentRoute == &quot;profile/${currentUser?.username}&quot;&#10;                    // Compara outras rotas pelo seu nome de classe qualificado&#10;                    else -&gt; currentRoute == item.route::class.qualifiedName&#10;                },&#10;                // 4. Lógica de clique TOTALMENTE CORRIGIDA&#10;                onClick = {&#10;                    when (item.route) {&#10;                        is Route.Profile -&gt; {&#10;                            // Ação para o perfil: só navega se tiver um username&#10;                            currentUser?.username?.let { username -&gt;&#10;                                navController.navigate(&quot;profile/$username&quot;) {&#10;                                    // Comportamento padrão para itens da bottom bar&#10;                                    popUpTo(navController.graph.startDestinationId) {&#10;                                        saveState = true&#10;                                    }&#10;                                    launchSingleTop = true&#10;                                    restoreState = true&#10;                                }&#10;                            }&#10;                        }&#10;                        else -&gt; {&#10;                            // Ação para outros itens (Home, List)&#10;                            navController.navigate(item.route) {&#10;                                // Comportamento padrão para itens da bottom bar&#10;                                popUpTo(navController.graph.startDestinationId) {&#10;                                    saveState = true&#10;                                }&#10;                                launchSingleTop = true&#10;                                restoreState = true&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/event/EventDetailsViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/event/EventDetailsViewModel.kt" />
              <option name="originalContent" value="package com.pdm.zone.ui.screens.event&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FieldValue&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.pdm.zone.data.model.Event&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;&#10;data class EventDetailsUiState(&#10;    val isLoading: Boolean = true,&#10;    val event: Event? = null,&#10;    val isCurrentUserConfirmed: Boolean = false,&#10;    val isCurrentUserInterested: Boolean = false,&#10;    val error: String? = null&#10;)&#10;&#10;class EventDetailsViewModel : ViewModel() {&#10;&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _uiState = MutableStateFlow(EventDetailsUiState())&#10;    val uiState: StateFlow&lt;EventDetailsUiState&gt; = _uiState.asStateFlow()&#10;&#10;    fun loadEvent(eventId: String) {&#10;        if (eventId.isBlank()) {&#10;            _uiState.update { it.copy(isLoading = false, error = &quot;ID do evento inválido.&quot;) }&#10;            return&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            _uiState.update { it.copy(isLoading = true) }&#10;            try {&#10;                val documentSnapshot = db.collection(&quot;events&quot;).document(eventId).get().await()&#10;&#10;                if (documentSnapshot.exists()) {&#10;                    val event = documentSnapshot.toObject(Event::class.java)&#10;                    if (event != null) {&#10;                        val currentUserId = auth.currentUser?.uid&#10;                        val isConfirmed = event.attendees.contains(currentUserId)&#10;                        val isInterested = event.interestedUsers.contains(currentUserId)&#10;&#10;                        _uiState.update {&#10;                            it.copy(&#10;                                isLoading = false,&#10;                                event = event,&#10;                                isCurrentUserConfirmed = isConfirmed,&#10;                                isCurrentUserInterested = isInterested,&#10;                                error = null&#10;                            )&#10;                        }&#10;                    } else {&#10;                        _uiState.update { it.copy(isLoading = false, error = &quot;Falha ao ler dados do evento.&quot;) }&#10;                    }&#10;                } else {&#10;                    _uiState.update { it.copy(isLoading = false, error = &quot;Evento não encontrado.&quot;) }&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.update {&#10;                    it.copy(isLoading = false, error = &quot;Falha ao carregar o evento: ${e.message}&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun togglePresenceConfirmation() {&#10;        viewModelScope.launch {&#10;            val currentState = _uiState.value&#10;            val event = currentState.event ?: return@launch&#10;            val currentUserId = auth.currentUser?.uid ?: return@launch&#10;&#10;            val isCurrentlyConfirmed = currentState.isCurrentUserConfirmed&#10;&#10;            val newAttendeesList = if (isCurrentlyConfirmed) {&#10;                event.attendees - currentUserId&#10;            } else {&#10;                event.attendees + currentUserId&#10;            }&#10;            _uiState.update {&#10;                it.copy(&#10;                    isCurrentUserConfirmed = !isCurrentlyConfirmed,&#10;                    event = event.copy(attendees = newAttendeesList)&#10;                )&#10;            }&#10;&#10;            try {&#10;                val eventRef = db.collection(&quot;events&quot;).document(event.id)&#10;                val fieldUpdate = if (isCurrentlyConfirmed) {&#10;                    FieldValue.arrayRemove(currentUserId)&#10;                } else {&#10;                    FieldValue.arrayUnion(currentUserId)&#10;                }&#10;                eventRef.update(&quot;attendees&quot;, fieldUpdate).await()&#10;            } catch (e: Exception) {&#10;                _uiState.update {&#10;                    currentState.copy(error = &quot;Ocorreu uma falha. Tente novamente.&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun toggleInterest() {&#10;        viewModelScope.launch {&#10;            val currentState = _uiState.value&#10;            val event = currentState.event ?: return@launch&#10;            val currentUserId = auth.currentUser?.uid ?: return@launch&#10;            val isCurrentlyInterested = currentState.isCurrentUserInterested&#10;            val newInterestedList = if (isCurrentlyInterested) event.interestedUsers - currentUserId else event.interestedUsers + currentUserId&#10;            _uiState.update { it.copy(isCurrentUserInterested = !isCurrentlyInterested, event = event.copy(interestedUsers = newInterestedList)) }&#10;            try {&#10;                val eventRef = db.collection(&quot;events&quot;).document(event.id)&#10;                val fieldUpdate = if (isCurrentlyInterested) FieldValue.arrayRemove(currentUserId) else FieldValue.arrayUnion(currentUserId)&#10;                eventRef.update(&quot;interestedUsers&quot;, fieldUpdate).await()&#10;            } catch (e: Exception) {&#10;                _uiState.update { currentState.copy(error = &quot;Ocorreu uma falha. Tente novamente.&quot;) }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.pdm.zone.ui.screens.event&#13;&#10;&#13;&#10;import androidx.lifecycle.ViewModel&#13;&#10;import androidx.lifecycle.viewModelScope&#13;&#10;import com.google.firebase.auth.FirebaseAuth&#13;&#10;import com.google.firebase.firestore.FieldValue&#13;&#10;import com.google.firebase.firestore.FirebaseFirestore&#13;&#10;import com.pdm.zone.data.model.Event&#13;&#10;import kotlinx.coroutines.flow.MutableStateFlow&#13;&#10;import kotlinx.coroutines.flow.StateFlow&#13;&#10;import kotlinx.coroutines.flow.asStateFlow&#13;&#10;import kotlinx.coroutines.flow.update&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;import kotlinx.coroutines.tasks.await&#13;&#10;&#13;&#10;data class EventDetailsUiState(&#13;&#10;    val isLoading: Boolean = true,&#13;&#10;    val event: Event? = null,&#13;&#10;    val isCurrentUserConfirmed: Boolean = false,&#13;&#10;    val isCurrentUserInterested: Boolean = false,&#13;&#10;    val error: String? = null&#13;&#10;)&#13;&#10;&#13;&#10;class EventDetailsViewModel : ViewModel() {&#13;&#10;&#13;&#10;    private val db = FirebaseFirestore.getInstance()&#13;&#10;    private val auth = FirebaseAuth.getInstance()&#13;&#10;&#13;&#10;    private val _uiState = MutableStateFlow(EventDetailsUiState())&#13;&#10;    val uiState: StateFlow&lt;EventDetailsUiState&gt; = _uiState.asStateFlow()&#13;&#10;&#13;&#10;    fun loadEvent(eventId: String) {&#13;&#10;        if (eventId.isBlank()) {&#13;&#10;            _uiState.update { it.copy(isLoading = false, error = &quot;ID do evento inválido.&quot;) }&#13;&#10;            return&#13;&#10;        }&#13;&#10;&#13;&#10;        viewModelScope.launch {&#13;&#10;            _uiState.update { it.copy(isLoading = true) }&#13;&#10;            try {&#13;&#10;                val documentSnapshot = db.collection(&quot;events&quot;).document(eventId).get().await()&#13;&#10;&#13;&#10;                if (documentSnapshot.exists()) {&#13;&#10;                    val event = documentSnapshot.toObject(Event::class.java)&#13;&#10;                    if (event != null) {&#13;&#10;                        val currentUserId = auth.currentUser?.uid&#13;&#10;                        val isConfirmed = event.attendees.contains(currentUserId)&#13;&#10;                        val isInterested = event.interestedUsers.contains(currentUserId)&#13;&#10;&#13;&#10;                        _uiState.update {&#13;&#10;                            it.copy(&#13;&#10;                                isLoading = false,&#13;&#10;                                event = event,&#13;&#10;                                isCurrentUserConfirmed = isConfirmed,&#13;&#10;                                isCurrentUserInterested = isInterested,&#13;&#10;                                error = null&#13;&#10;                            )&#13;&#10;                        }&#13;&#10;                    } else {&#13;&#10;                        _uiState.update { it.copy(isLoading = false, error = &quot;Falha ao ler dados do evento.&quot;) }&#13;&#10;                    }&#13;&#10;                } else {&#13;&#10;                    _uiState.update { it.copy(isLoading = false, error = &quot;Evento não encontrado.&quot;) }&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                _uiState.update {&#13;&#10;                    it.copy(isLoading = false, error = &quot;Falha ao carregar o evento: ${e.message}&quot;)&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun togglePresenceConfirmation() {&#13;&#10;        viewModelScope.launch {&#13;&#10;            val currentState = _uiState.value&#13;&#10;            val event = currentState.event ?: return@launch&#13;&#10;            val currentUserId = auth.currentUser?.uid ?: return@launch&#13;&#10;&#13;&#10;            val isCurrentlyConfirmed = currentState.isCurrentUserConfirmed&#13;&#10;&#13;&#10;            val newAttendeesList = if (isCurrentlyConfirmed) {&#13;&#10;                event.attendees - currentUserId&#13;&#10;            } else {&#13;&#10;                event.attendees + currentUserId&#13;&#10;            }&#13;&#10;            &#13;&#10;            // Atualizando o estado local imediatamente para feedback instantâneo&#13;&#10;            _uiState.update {&#13;&#10;                it.copy(&#13;&#10;                    isCurrentUserConfirmed = !isCurrentlyConfirmed,&#13;&#10;                    event = event.copy(attendees = newAttendeesList)&#13;&#10;                )&#13;&#10;            }&#13;&#10;&#13;&#10;            try {&#13;&#10;                val eventRef = db.collection(&quot;events&quot;).document(event.id)&#13;&#10;                val fieldUpdate = if (isCurrentlyConfirmed) {&#13;&#10;                    FieldValue.arrayRemove(currentUserId)&#13;&#10;                } else {&#13;&#10;                    FieldValue.arrayUnion(currentUserId)&#13;&#10;                }&#13;&#10;                &#13;&#10;                // Atualiza o evento no Firestore&#13;&#10;                eventRef.update(&quot;attendees&quot;, fieldUpdate).await()&#13;&#10;                &#13;&#10;                // Se o usuário desconfirmar presença e estava interessado, mantém na lista de interessados&#13;&#10;                if (isCurrentlyConfirmed &amp;&amp; !currentState.isCurrentUserInterested) {&#13;&#10;                    eventRef.update(&quot;interestedUsers&quot;, FieldValue.arrayUnion(currentUserId)).await()&#13;&#10;                    _uiState.update {&#13;&#10;                        it.copy(&#13;&#10;                            isCurrentUserInterested = true,&#13;&#10;                            event = it.event?.copy(&#13;&#10;                                interestedUsers = it.event.interestedUsers + currentUserId&#13;&#10;                            )&#13;&#10;                        )&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                // Em caso de erro, revertemos para o estado anterior&#13;&#10;                _uiState.update {&#13;&#10;                    currentState.copy(error = &quot;Ocorreu uma falha. Tente novamente.&quot;)&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun toggleInterest() {&#13;&#10;        viewModelScope.launch {&#13;&#10;            val currentState = _uiState.value&#13;&#10;            val event = currentState.event ?: return@launch&#13;&#10;            val currentUserId = auth.currentUser?.uid ?: return@launch&#13;&#10;            val isCurrentlyInterested = currentState.isCurrentUserInterested&#13;&#10;            val newInterestedList = if (isCurrentlyInterested) event.interestedUsers - currentUserId else event.interestedUsers + currentUserId&#13;&#10;            _uiState.update { it.copy(isCurrentUserInterested = !isCurrentlyInterested, event = event.copy(interestedUsers = newInterestedList)) }&#13;&#10;            try {&#13;&#10;                val eventRef = db.collection(&quot;events&quot;).document(event.id)&#13;&#10;                val fieldUpdate = if (isCurrentlyInterested) FieldValue.arrayRemove(currentUserId) else FieldValue.arrayUnion(currentUserId)&#13;&#10;                eventRef.update(&quot;interestedUsers&quot;, fieldUpdate).await()&#13;&#10;            } catch (e: Exception) {&#13;&#10;                _uiState.update { currentState.copy(error = &quot;Ocorreu uma falha. Tente novamente.&quot;) }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/event/EventListPage.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/event/EventListPage.kt" />
              <option name="originalContent" value="package com.pdm.zone.ui.screens.event&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.LocationOn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavHostController&#10;import coil.compose.AsyncImage&#10;import coil.request.ImageRequest&#10;import com.pdm.zone.R&#10;import com.pdm.zone.data.model.Event&#10;import com.pdm.zone.ui.theme.Primary&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;@Composable&#10;fun ListPage(&#10;    navController: NavHostController,&#10;    viewModel: ListViewModel = viewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsState()&#10;    val dateFormatter = remember { SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale(&quot;pt&quot;, &quot;BR&quot;)) }&#10;    val timeFormatter = remember { SimpleDateFormat(&quot;HH:mm&quot;, Locale(&quot;pt&quot;, &quot;BR&quot;)) }&#10;&#10;    Scaffold { innerPadding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(innerPadding)&#10;        ) {&#10;            // Título da página&#10;            Text(&#10;                text = &quot;Meus Eventos&quot;,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = 24.sp,&#10;                color = Primary,&#10;                modifier = Modifier.padding(horizontal = 16.dp, vertical = 16.dp)&#10;            )&#10;&#10;            // Conteúdo dos eventos&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(8.dp)&#10;            ) {&#10;                when {&#10;                    uiState.isLoading -&gt; {&#10;                        CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))&#10;                    }&#10;                    uiState.error != null -&gt; {&#10;                        Text(&#10;                            text = uiState.error!!,&#10;                            modifier = Modifier.align(Alignment.Center),&#10;                            color = Color.Red&#10;                        )&#10;                    }&#10;                    else -&gt; {&#10;                        if (uiState.confirmedEvents.isEmpty()) {&#10;                            Box(&#10;                                modifier = Modifier.fillMaxSize(),&#10;                                contentAlignment = Alignment.Center&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;Você não confirmou presença em nenhum evento próximo&quot;,&#10;                                    color = Color.Gray,&#10;                                    modifier = Modifier.padding(16.dp)&#10;                                )&#10;                            }&#10;                        } else {&#10;                            LazyColumn(&#10;                                modifier = Modifier.fillMaxSize(),&#10;                                contentPadding = PaddingValues(vertical = 8.dp)&#10;                            ) {&#10;                                items(uiState.confirmedEvents) { event -&gt;&#10;                                    Card(&#10;                                        modifier = Modifier&#10;                                            .fillMaxWidth()&#10;                                            .padding(vertical = 8.dp, horizontal = 16.dp)&#10;                                            .clickable {&#10;                                                navController.navigate(&quot;eventDetails/${event.id}&quot;)&#10;                                            }&#10;                                    ) {&#10;                                        Row(&#10;                                            modifier = Modifier&#10;                                                .fillMaxWidth()&#10;                                                .padding(8.dp),&#10;                                            verticalAlignment = Alignment.CenterVertically&#10;                                        ) {&#10;                                            // Imagem do evento&#10;                                            AsyncImage(&#10;                                                model = ImageRequest.Builder(LocalContext.current)&#10;                                                    .data(event.imageUrl)&#10;                                                    .crossfade(true)&#10;                                                    .build(),&#10;                                                placeholder = painterResource(R.drawable.placeholder_event),&#10;                                                contentDescription = event.title,&#10;                                                contentScale = ContentScale.Crop,&#10;                                                modifier = Modifier&#10;                                                    .size(100.dp)&#10;                                                    .padding(end = 8.dp)&#10;                                            )&#10;&#10;                                            // Detalhes do evento&#10;                                            Column(&#10;                                                modifier = Modifier&#10;                                                    .weight(1f)&#10;                                                    .padding(start = 8.dp)&#10;                                            ) {&#10;                                                // Título&#10;                                                Text(&#10;                                                    text = event.title,&#10;                                                    style = MaterialTheme.typography.titleMedium,&#10;                                                    color = Primary,&#10;                                                    fontWeight = FontWeight.Bold&#10;                                                )&#10;&#10;                                                // Local&#10;                                                Row(&#10;                                                    verticalAlignment = Alignment.CenterVertically,&#10;                                                    modifier = Modifier.padding(top = 4.dp)&#10;                                                ) {&#10;                                                    Icon(&#10;                                                        Icons.Default.LocationOn,&#10;                                                        contentDescription = &quot;Local&quot;,&#10;                                                        tint = Color.Gray,&#10;                                                        modifier = Modifier.size(16.dp)&#10;                                                    )&#10;                                                    Spacer(modifier = Modifier.width(4.dp))&#10;                                                    Text(&#10;                                                        text = event.location,&#10;                                                        style = MaterialTheme.typography.bodySmall,&#10;                                                        color = Color.Gray&#10;                                                    )&#10;                                                }&#10;&#10;                                                // Data&#10;                                                event.eventDate?.let { date -&gt;&#10;                                                    Row(&#10;                                                        verticalAlignment = Alignment.CenterVertically,&#10;                                                        modifier = Modifier.padding(top = 4.dp)&#10;                                                    ) {&#10;                                                        Text(&#10;                                                            text = &quot;Data:&quot;,&#10;                                                            style = MaterialTheme.typography.bodySmall,&#10;                                                            fontWeight = FontWeight.Bold,&#10;                                                            color = Color.Gray&#10;                                                        )&#10;                                                        Spacer(modifier = Modifier.width(4.dp))&#10;                                                        Text(&#10;                                                            text = dateFormatter.format(date),&#10;                                                            style = MaterialTheme.typography.bodySmall,&#10;                                                            color = Color.Gray&#10;                                                        )&#10;                                                    }&#10;                                                }&#10;&#10;                                                // Horário&#10;                                                Row(&#10;                                                    verticalAlignment = Alignment.CenterVertically,&#10;                                                    modifier = Modifier.padding(top = 4.dp)&#10;                                                ) {&#10;                                                    Text(&#10;                                                        text = &quot;Horário:&quot;,&#10;                                                        style = MaterialTheme.typography.bodySmall,&#10;                                                        fontWeight = FontWeight.Bold,&#10;                                                        color = Color.Gray&#10;                                                    )&#10;                                                    Spacer(modifier = Modifier.width(4.dp))&#10;                                                    Text(&#10;                                                        text = &quot;${event.startTime ?: &quot;--:--&quot;} - ${event.endTime ?: &quot;--:--&quot;}&quot;,&#10;                                                        style = MaterialTheme.typography.bodySmall,&#10;                                                        color = Color.Gray&#10;                                                    )&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.pdm.zone.ui.screens.event&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.LocationOn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavHostController&#10;import coil.compose.AsyncImage&#10;import coil.request.ImageRequest&#10;import com.pdm.zone.R&#10;import com.pdm.zone.data.model.Event&#10;import com.pdm.zone.ui.components.CompactEventCard&#10;import com.pdm.zone.ui.theme.Primary&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;@Composable&#10;fun ListPage(&#10;    navController: NavHostController,&#10;    viewModel: ListViewModel = viewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsState()&#10;    val dateFormatter = remember { SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale(&quot;pt&quot;, &quot;BR&quot;)) }&#10;    val timeFormatter = remember { SimpleDateFormat(&quot;HH:mm&quot;, Locale(&quot;pt&quot;, &quot;BR&quot;)) }&#10;&#10;    Scaffold { innerPadding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(innerPadding)&#10;        ) {&#10;            // Título da página&#10;            Text(&#10;                text = &quot;Meus Eventos&quot;,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = 24.sp,&#10;                color = Primary,&#10;                modifier = Modifier.padding(horizontal = 16.dp, vertical = 16.dp)&#10;            )&#10;&#10;            // Conteúdo dos eventos&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(8.dp)&#10;            ) {&#10;                when {&#10;                    uiState.isLoading -&gt; {&#10;                        CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))&#10;                    }&#10;                    uiState.error != null -&gt; {&#10;                        Text(&#10;                            text = uiState.error!!,&#10;                            modifier = Modifier.align(Alignment.Center),&#10;                            color = Color.Red&#10;                        )&#10;                    }&#10;                    else -&gt; {&#10;                        if (uiState.confirmedEvents.isEmpty()) {&#10;                            Box(&#10;                                modifier = Modifier.fillMaxSize(),&#10;                                contentAlignment = Alignment.Center&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;Você não confirmou presença em nenhum evento próximo&quot;,&#10;                                    color = Color.Gray,&#10;                                    modifier = Modifier.padding(16.dp)&#10;                                )&#10;                            }&#10;                        } else {&#10;                            LazyColumn(&#10;                                modifier = Modifier.fillMaxSize(),&#10;                                contentPadding = PaddingValues(vertical = 8.dp)&#10;                            ) {&#10;                                items(uiState.confirmedEvents) { event -&gt;&#10;                                    CompactEventCard(&#10;                                        event = event,&#10;                                        onCardClick = {&#10;                                            navController.navigate(&quot;eventDetails/${it.id}&quot;)&#10;                                        }&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/event/EventListViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/event/EventListViewModel.kt" />
              <option name="originalContent" value="package com.pdm.zone.ui.screens.event&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.Query&#10;import com.pdm.zone.data.model.Event&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;import java.util.Date&#10;&#10;// Estado da UI específico para a tela de lista de eventos&#10;data class ListUiState(&#10;    val isLoading: Boolean = true,&#10;    val confirmedUpcomingEvents: List&lt;Event&gt; = emptyList(),&#10;    val confirmedPastEvents: List&lt;Event&gt; = emptyList(),&#10;    val error: String? = null&#10;)&#10;&#10;class ListViewModel : ViewModel() {&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _uiState = MutableStateFlow(ListUiState())&#10;    val uiState = _uiState.asStateFlow()&#10;&#10;    init {&#10;        loadUserConfirmedEvents()&#10;    }&#10;&#10;    fun loadUserConfirmedEvents() {&#10;        viewModelScope.launch {&#10;            _uiState.update { it.copy(isLoading = true) }&#10;            try {&#10;                val currentUserId = auth.currentUser?.uid&#10;                if (currentUserId == null) {&#10;                    _uiState.update { it.copy(isLoading = false, error = &quot;Usuário não autenticado&quot;) }&#10;                    return@launch&#10;                }&#10;&#10;                // Busca eventos que o usuário confirmou presença&#10;                val eventsSnapshot = db.collection(&quot;events&quot;)&#10;                    .whereArrayContains(&quot;attendees&quot;, currentUserId)&#10;                    .orderBy(&quot;eventDate&quot;, Query.Direction.ASCENDING)&#10;                    .get()&#10;                    .await()&#10;&#10;                val allConfirmedEvents = eventsSnapshot.toObjects(Event::class.java)&#10;&#10;                // Separar eventos por data (passados e futuros)&#10;                val currentDate = Date()&#10;                val (upcoming, past) = allConfirmedEvents.partition { event -&gt;&#10;                    event.eventDate?.after(currentDate) ?: false&#10;                }&#10;&#10;                _uiState.update {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        confirmedUpcomingEvents = upcoming,&#10;                        confirmedPastEvents = past,&#10;                        error = null&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.update {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        error = &quot;Falha ao carregar eventos: ${e.message}&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.pdm.zone.ui.screens.event&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.pdm.zone.data.model.Event&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;import java.util.Date&#10;&#10;// Estado da UI específico para a tela de lista de eventos&#10;data class ListUiState(&#10;    val isLoading: Boolean = true,&#10;    val confirmedEvents: List&lt;Event&gt; = emptyList(),&#10;    val error: String? = null&#10;)&#10;&#10;class ListViewModel : ViewModel() {&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _uiState = MutableStateFlow(ListUiState())&#10;    val uiState = _uiState.asStateFlow()&#10;&#10;    init {&#10;        loadUserConfirmedEvents()&#10;    }&#10;&#10;    fun loadUserConfirmedEvents() {&#10;        viewModelScope.launch {&#10;            _uiState.update { it.copy(isLoading = true) }&#10;            try {&#10;                val currentUserId = auth.currentUser?.uid&#10;                if (currentUserId == null) {&#10;                    _uiState.update { it.copy(isLoading = false, error = &quot;Usuário não autenticado&quot;) }&#10;                    return@launch&#10;                }&#10;&#10;                // Busca eventos que o usuário confirmou presença&#10;                // Note que removemos o orderBy para evitar o erro de índice&#10;                val eventsSnapshot = db.collection(&quot;events&quot;)&#10;                    .whereArrayContains(&quot;attendees&quot;, currentUserId)&#10;                    .get()&#10;                    .await()&#10;&#10;                val allConfirmedEvents = eventsSnapshot.toObjects(Event::class.java)&#10;&#10;                // Separar apenas eventos futuros e ordenar por data&#10;                val currentDate = Date()&#10;                val upcomingEvents = allConfirmedEvents&#10;                    .filter { event -&gt; event.eventDate?.after(currentDate) ?: false }&#10;                    .sortedBy { it.eventDate }&#10;&#10;                _uiState.update {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        confirmedEvents = upcomingEvents,&#10;                        error = null&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.update {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        error = &quot;Falha ao carregar eventos: ${e.message}&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/home/Home.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/home/Home.kt" />
              <option name="originalContent" value="package com.pdm.zone.ui.screens.home&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavHostController&#10;import com.pdm.zone.data.model.EventCategory&#10;import com.pdm.zone.ui.components.EventCard&#10;import com.pdm.zone.ui.theme.Primary&#10;import com.pdm.zone.ui.nav.Route&#10;&#10;@Composable&#10;fun HomePage(&#10;    navController: NavHostController,&#10;    viewModel: HomeViewModel = viewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsState()&#10;    var selectedCategory by remember { mutableStateOf&lt;EventCategory?&gt;(null) }&#10;&#10;    // Efeito para atualizar eventos quando a tela é recomposta&#10;    LaunchedEffect(Unit) {&#10;        viewModel.loadEvents()&#10;    }&#10;&#10;    Scaffold { innerPadding -&gt;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(innerPadding)&#10;        ) {&#10;            when {&#10;                uiState.isLoading -&gt; {&#10;                    CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))&#10;                }&#10;                uiState.error != null -&gt; {&#10;                    Text(&#10;                        text = uiState.error!!,&#10;                        modifier = Modifier.align(Alignment.Center)&#10;                    )&#10;                }&#10;                else -&gt; {&#10;                    LazyColumn(&#10;                        contentPadding = PaddingValues(bottom = 16.dp)&#10;                    ) {&#10;                        // Filtros de categoria&#10;                        item {&#10;                            LazyRow(&#10;                                horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                                contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp)&#10;                            ) {&#10;                                items(EventCategory.values()) { category -&gt;&#10;                                    FilterChip(&#10;                                        selected = selectedCategory == category,&#10;                                        onClick = {&#10;                                            selectedCategory = if (selectedCategory == category) null else category&#10;                                        },&#10;                                        label = { Text(category.displayName) }&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;&#10;                        // Título da página&#10;                        item {&#10;                            Text(&#10;                                text = &quot;Próximos Eventos&quot;,&#10;                                fontWeight = FontWeight.Bold,&#10;                                fontSize = 24.sp,&#10;                                color = Primary,&#10;                                modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp)&#10;                            )&#10;                        }&#10;&#10;                        // Botão para ver eventos confirmados&#10;                        item {&#10;                            Button(&#10;                                onClick = { navController.navigate(Route.List.toString()) },&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(horizontal = 16.dp, vertical = 8.dp),&#10;                                colors = ButtonDefaults.buttonColors(&#10;                                    containerColor = Primary&#10;                                )&#10;                            ) {&#10;                                Text(&quot;Ver meus eventos confirmados&quot;)&#10;                            }&#10;&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                        }&#10;&#10;                        // Lista de eventos próximos filtrados&#10;                        val filteredEvents = selectedCategory?.let { cat -&gt;&#10;                            uiState.upcomingEvents.filter { it.category == cat }&#10;                        } ?: uiState.upcomingEvents&#10;&#10;                        if (filteredEvents.isEmpty()) {&#10;                            item {&#10;                                Box(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .height(100.dp),&#10;                                    contentAlignment = Alignment.Center&#10;                                ) {&#10;                                    Text(&#10;                                        text = &quot;Nenhum evento encontrado&quot;,&#10;                                        color = Color.Gray&#10;                                    )&#10;                                }&#10;                            }&#10;                        } else {&#10;                            items(filteredEvents) { event -&gt;&#10;                                EventCard(&#10;                                    event = event,&#10;                                    onCardClick = {&#10;                                        navController.navigate(&quot;eventDetails/${it.id}&quot;)&#10;                                    }&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.pdm.zone.ui.screens.home&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavHostController&#10;import com.pdm.zone.data.model.EventCategory&#10;import com.pdm.zone.ui.components.EventCard&#10;import com.pdm.zone.ui.theme.Primary&#10;&#10;@Composable&#10;fun HomePage(&#10;    navController: NavHostController,&#10;    viewModel: HomeViewModel = viewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsState()&#10;    var selectedCategory by remember { mutableStateOf&lt;EventCategory?&gt;(null) }&#10;&#10;    // Efeito para atualizar eventos quando a tela é recomposta&#10;    LaunchedEffect(Unit) {&#10;        viewModel.loadEvents()&#10;    }&#10;&#10;    Scaffold { innerPadding -&gt;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(innerPadding)&#10;        ) {&#10;            when {&#10;                uiState.isLoading -&gt; {&#10;                    CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))&#10;                }&#10;                uiState.error != null -&gt; {&#10;                    Text(&#10;                        text = uiState.error!!,&#10;                        modifier = Modifier.align(Alignment.Center)&#10;                    )&#10;                }&#10;                else -&gt; {&#10;                    LazyColumn(&#10;                        contentPadding = PaddingValues(bottom = 16.dp)&#10;                    ) {&#10;                        // Filtros de categoria&#10;                        item {&#10;                            LazyRow(&#10;                                horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                                contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp)&#10;                            ) {&#10;                                items(EventCategory.values()) { category -&gt;&#10;                                    FilterChip(&#10;                                        selected = selectedCategory == category,&#10;                                        onClick = {&#10;                                            selectedCategory = if (selectedCategory == category) null else category&#10;                                        },&#10;                                        label = { Text(category.displayName) }&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;&#10;                        // Título da página&#10;                        item {&#10;                            Text(&#10;                                text = &quot;Próximos Eventos&quot;,&#10;                                fontWeight = FontWeight.Bold,&#10;                                fontSize = 24.sp,&#10;                                color = Primary,&#10;                                modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp)&#10;                            )&#10;                        }&#10;&#10;                        // Lista de eventos próximos filtrados&#10;                        val filteredEvents = selectedCategory?.let { cat -&gt;&#10;                            uiState.upcomingEvents.filter { it.category == cat }&#10;                        } ?: uiState.upcomingEvents&#10;&#10;                        if (filteredEvents.isEmpty()) {&#10;                            item {&#10;                                Box(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .height(100.dp),&#10;                                    contentAlignment = Alignment.Center&#10;                                ) {&#10;                                    Text(&#10;                                        text = &quot;Nenhum evento encontrado&quot;,&#10;                                        color = Color.Gray&#10;                                    )&#10;                                }&#10;                            }&#10;                        } else {&#10;                            items(filteredEvents) { event -&gt;&#10;                                EventCard(&#10;                                    event = event,&#10;                                    onCardClick = {&#10;                                        navController.navigate(&quot;eventDetails/${it.id}&quot;)&#10;                                    }&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/home/HomeViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/home/HomeViewModel.kt" />
              <option name="originalContent" value="package com.pdm.zone.ui.screens.home&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.Query&#10;import com.pdm.zone.data.model.Event&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;import java.util.Date&#10;&#10;data class HomeUiState(&#10;    val isLoading: Boolean = true,&#10;    val upcomingEvents: List&lt;Event&gt; = emptyList(),&#10;    val pastEvents: List&lt;Event&gt; = emptyList(),&#10;    val userConfirmedEvents: List&lt;Event&gt; = emptyList(), // Eventos que o usuário confirmou presença&#10;    val error: String? = null&#10;)&#10;&#10;class HomeViewModel : ViewModel() {&#10;&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _uiState = MutableStateFlow(HomeUiState())&#10;    val uiState = _uiState.asStateFlow()&#10;&#10;    init {&#10;        loadEvents()&#10;    }&#10;&#10;    fun loadEvents() {&#10;        viewModelScope.launch {&#10;            _uiState.update { it.copy(isLoading = true) }&#10;            try {&#10;                val currentUserId = auth.currentUser?.uid&#10;                if (currentUserId == null) {&#10;                    _uiState.update { it.copy(isLoading = false, error = &quot;Usuário não autenticado&quot;) }&#10;                    return@launch&#10;                }&#10;&#10;                // Carregar todos os eventos&#10;                val allEventsSnapshot = db.collection(&quot;events&quot;)&#10;                    .orderBy(&quot;eventDate&quot;, Query.Direction.ASCENDING)&#10;                    .get()&#10;                    .await()&#10;&#10;                val allEvents = allEventsSnapshot.toObjects(Event::class.java)&#10;&#10;                // Carregar eventos que o usuário confirmou presença&#10;                val userEventsSnapshot = db.collection(&quot;events&quot;)&#10;                    .whereArrayContains(&quot;attendees&quot;, currentUserId)&#10;                    .get()&#10;                    .await()&#10;&#10;                val userEvents = userEventsSnapshot.toObjects(Event::class.java)&#10;&#10;                // Separar eventos por data (passados e futuros)&#10;                val currentDate = Date()&#10;                val (upcoming, past) = allEvents.partition { event -&gt;&#10;                    event.eventDate?.after(currentDate) ?: false&#10;                }&#10;&#10;                // Separar os eventos confirmados do usuário entre futuros e passados&#10;                val userConfirmedEvents = userEvents.filter { event -&gt;&#10;                    event.eventDate?.after(currentDate) ?: false&#10;                }&#10;&#10;                _uiState.update {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        upcomingEvents = upcoming,&#10;                        pastEvents = past,&#10;                        userConfirmedEvents = userConfirmedEvents&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.update {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        error = &quot;Falha ao carregar eventos: ${e.message}&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Chamado quando o usuário confirma/cancela presença em um evento na tela de detalhes&#10;    fun refreshEvents() {&#10;        loadEvents()&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.pdm.zone.ui.screens.home&#13;&#10;&#13;&#10;import androidx.lifecycle.ViewModel&#13;&#10;import androidx.lifecycle.viewModelScope&#13;&#10;import com.google.firebase.auth.FirebaseAuth&#13;&#10;import com.google.firebase.firestore.FirebaseFirestore&#13;&#10;import com.google.firebase.firestore.Query&#13;&#10;import com.pdm.zone.data.model.Event&#13;&#10;import kotlinx.coroutines.flow.MutableStateFlow&#13;&#10;import kotlinx.coroutines.flow.asStateFlow&#13;&#10;import kotlinx.coroutines.flow.update&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;import kotlinx.coroutines.tasks.await&#13;&#10;import java.util.Date&#13;&#10;&#13;&#10;data class HomeUiState(&#13;&#10;    val isLoading: Boolean = true,&#13;&#10;    val upcomingEvents: List&lt;Event&gt; = emptyList(),&#13;&#10;    val error: String? = null&#13;&#10;)&#13;&#10;&#13;&#10;class HomeViewModel : ViewModel() {&#13;&#10;&#13;&#10;    private val db = FirebaseFirestore.getInstance()&#13;&#10;    private val auth = FirebaseAuth.getInstance()&#13;&#10;&#13;&#10;    private val _uiState = MutableStateFlow(HomeUiState())&#13;&#10;    val uiState = _uiState.asStateFlow()&#13;&#10;&#13;&#10;    init {&#13;&#10;        loadEvents()&#13;&#10;    }&#13;&#10;&#13;&#10;    fun loadEvents() {&#13;&#10;        viewModelScope.launch {&#13;&#10;            _uiState.update { it.copy(isLoading = true) }&#13;&#10;            try {&#13;&#10;                // Carregar todos os eventos&#13;&#10;                val allEventsSnapshot = db.collection(&quot;events&quot;)&#13;&#10;                    .orderBy(&quot;eventDate&quot;, Query.Direction.ASCENDING)&#13;&#10;                    .get()&#13;&#10;                    .await()&#13;&#10;&#13;&#10;                val allEvents = allEventsSnapshot.toObjects(Event::class.java)&#13;&#10;&#13;&#10;                // Separar eventos por data (apenas eventos futuros)&#13;&#10;                val currentDate = Date()&#13;&#10;                val upcomingEvents = allEvents.filter { event -&gt;&#13;&#10;                    event.eventDate?.after(currentDate) ?: false&#13;&#10;                }&#13;&#10;&#13;&#10;                _uiState.update {&#13;&#10;                    it.copy(&#13;&#10;                        isLoading = false,&#13;&#10;                        upcomingEvents = upcomingEvents&#13;&#10;                    )&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                _uiState.update {&#13;&#10;                    it.copy(&#13;&#10;                        isLoading = false,&#13;&#10;                        error = &quot;Falha ao carregar eventos: ${e.message}&quot;&#13;&#10;                    )&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Chamado quando o usuário confirma/cancela presença em um evento na tela de detalhes&#13;&#10;    fun refreshEvents() {&#13;&#10;        loadEvents()&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/user/ProfileViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/user/ProfileViewModel.kt" />
              <option name="originalContent" value="package com.pdm.zone.ui.screens.user&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FieldValue&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.pdm.zone.data.model.User&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;&#10;data class ProfileUiState(&#10;    val user: User? = null,&#10;    val isLoading: Boolean = true,&#10;    val isCurrentUserProfile: Boolean = false,&#10;    val isFollowing: Boolean = false,&#10;    val error: String? = null&#10;)&#10;&#10;class ProfileViewModel : ViewModel() {&#10;&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _uiState = MutableStateFlow(ProfileUiState())&#10;    val uiState: StateFlow&lt;ProfileUiState&gt; = _uiState.asStateFlow()&#10;&#10;    fun loadUserProfile(username: String) {&#10;        viewModelScope.launch {&#10;            _uiState.update { it.copy(isLoading = true, error = null) }&#10;            try {&#10;                val currentUserId = auth.currentUser?.uid&#10;                if (currentUserId == null) {&#10;                    _uiState.update { it.copy(isLoading = false, error = &quot;Usuário não autenticado.&quot;) }&#10;                    return@launch&#10;                }&#10;&#10;                val querySnapshot = db.collection(&quot;users&quot;)&#10;                    .whereEqualTo(&quot;username&quot;, username)&#10;                    .get()&#10;                    .await()&#10;&#10;                if (querySnapshot.isEmpty) {&#10;                    _uiState.update { it.copy(isLoading = false, error = &quot;Usuário não encontrado.&quot;) }&#10;                    return@launch&#10;                }&#10;&#10;                val userDocument = querySnapshot.documents.first()&#10;                val profileUser = userDocument.toObject(User::class.java)?.copy(uid = userDocument.id)&#10;&#10;                if (profileUser == null) {&#10;                    _uiState.update { it.copy(isLoading = false, error = &quot;Falha ao ler dados do perfil.&quot;) }&#10;                    return@launch&#10;                }&#10;&#10;                val isCurrentUserProfile = profileUser.uid == currentUserId&#10;                val isFollowing = profileUser.followers.contains(currentUserId)&#10;&#10;                _uiState.update {&#10;                    it.copy(&#10;                        user = profileUser,&#10;                        isCurrentUserProfile = isCurrentUserProfile,&#10;                        isFollowing = isFollowing,&#10;                        isLoading = false&#10;                    )&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                _uiState.update { it.copy(isLoading = false, error = &quot;Erro ao carregar perfil: ${e.message}&quot;) }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun toggleFollow() {&#10;        viewModelScope.launch {&#10;            val profileUser = _uiState.value.user ?: return@launch&#10;            val currentUser = auth.currentUser ?: return@launch&#10;&#10;            val isCurrentlyFollowing = _uiState.value.isFollowing&#10;&#10;            try {&#10;                // 1. Atualizar o estado UI imediatamente para feedback instantâneo&#10;                val updatedFollowersList = profileUser.followers.toMutableList()&#10;&#10;                if (isCurrentlyFollowing) {&#10;                    updatedFollowersList.remove(currentUser.uid)&#10;                } else {&#10;                    updatedFollowersList.add(currentUser.uid)&#10;                }&#10;&#10;                // Criar uma cópia atualizada do user com a nova lista de seguidores&#10;                val updatedUser = profileUser.copy(followers = updatedFollowersList)&#10;&#10;                // Atualizar o estado com o user modificado e o novo status de isFollowing&#10;                _uiState.update {&#10;                    it.copy(&#10;                        user = updatedUser,&#10;                        isFollowing = !isCurrentlyFollowing&#10;                    )&#10;                }&#10;&#10;                // 2. Persistir as mudanças no Firestore&#10;                val currentUserRef = db.collection(&quot;users&quot;).document(currentUser.uid)&#10;                val profileUserRef = db.collection(&quot;users&quot;).document(profileUser.uid)&#10;&#10;                if (isCurrentlyFollowing) {&#10;                    currentUserRef.update(&quot;following&quot;, FieldValue.arrayRemove(profileUser.uid))&#10;                    profileUserRef.update(&quot;followers&quot;, FieldValue.arrayRemove(currentUser.uid))&#10;                } else {&#10;                    currentUserRef.update(&quot;following&quot;, FieldValue.arrayUnion(profileUser.uid))&#10;                    profileUserRef.update(&quot;followers&quot;, FieldValue.arrayUnion(currentUser.uid))&#10;                }&#10;            } catch(e: Exception) {&#10;                // Em caso de erro, reverter para o estado anterior&#10;                _uiState.update { it.copy(isFollowing = isCurrentlyFollowing, error = &quot;Ocorreu um erro ao atualizar.&quot;) }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.pdm.zone.ui.screens.user&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FieldValue&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.pdm.zone.data.model.User&#10;import com.pdm.zone.data.model.Event&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;import java.util.Date&#10;&#10;data class ProfileUiState(&#10;    val user: User? = null,&#10;    val isLoading: Boolean = true,&#10;    val isCurrentUserProfile: Boolean = false,&#10;    val isFollowing: Boolean = false,&#10;    val error: String? = null,&#10;    val upcomingEvents: List&lt;Event&gt; = emptyList(),&#10;    val pastEvents: List&lt;Event&gt; = emptyList(),&#10;    val isLoadingEvents: Boolean = false&#10;)&#10;&#10;class ProfileViewModel : ViewModel() {&#10;&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _uiState = MutableStateFlow(ProfileUiState())&#10;    val uiState: StateFlow&lt;ProfileUiState&gt; = _uiState.asStateFlow()&#10;&#10;    fun loadUserProfile(username: String) {&#10;        viewModelScope.launch {&#10;            _uiState.update { it.copy(isLoading = true, error = null) }&#10;            try {&#10;                val currentUserId = auth.currentUser?.uid&#10;                if (currentUserId == null) {&#10;                    _uiState.update { it.copy(isLoading = false, error = &quot;Usuário não autenticado.&quot;) }&#10;                    return@launch&#10;                }&#10;&#10;                val querySnapshot = db.collection(&quot;users&quot;)&#10;                    .whereEqualTo(&quot;username&quot;, username)&#10;                    .get()&#10;                    .await()&#10;&#10;                if (querySnapshot.isEmpty) {&#10;                    _uiState.update { it.copy(isLoading = false, error = &quot;Usuário não encontrado.&quot;) }&#10;                    return@launch&#10;                }&#10;&#10;                val userDocument = querySnapshot.documents.first()&#10;                val profileUser = userDocument.toObject(User::class.java)?.copy(uid = userDocument.id)&#10;&#10;                if (profileUser == null) {&#10;                    _uiState.update { it.copy(isLoading = false, error = &quot;Falha ao ler dados do perfil.&quot;) }&#10;                    return@launch&#10;                }&#10;&#10;                val isCurrentUserProfile = profileUser.uid == currentUserId&#10;                val isFollowing = profileUser.followers.contains(currentUserId)&#10;&#10;                _uiState.update {&#10;                    it.copy(&#10;                        user = profileUser,&#10;                        isCurrentUserProfile = isCurrentUserProfile,&#10;                        isFollowing = isFollowing,&#10;                        isLoading = false&#10;                    )&#10;                }&#10;                &#10;                // Carregar eventos do usuário&#10;                loadUserEvents(profileUser.uid)&#10;&#10;            } catch (e: Exception) {&#10;                _uiState.update { it.copy(isLoading = false, error = &quot;Erro ao carregar perfil: ${e.message}&quot;) }&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun loadUserEvents(userId: String) {&#10;        viewModelScope.launch {&#10;            _uiState.update { it.copy(isLoadingEvents = true) }&#10;            try {&#10;                val eventsSnapshot = db.collection(&quot;events&quot;)&#10;                    .whereArrayContains(&quot;attendees&quot;, userId)&#10;                    .get()&#10;                    .await()&#10;                    &#10;                val allEvents = eventsSnapshot.documents.mapNotNull { doc -&gt;&#10;                    doc.toObject(Event::class.java)&#10;                }&#10;                &#10;                val currentDate = Date()&#10;                val (upcoming, past) = allEvents.partition { event -&gt;&#10;                    event.eventDate?.after(currentDate) ?: false&#10;                }&#10;                &#10;                _uiState.update { &#10;                    it.copy(&#10;                        upcomingEvents = upcoming,&#10;                        pastEvents = past,&#10;                        isLoadingEvents = false&#10;                    )&#10;                }&#10;                &#10;            } catch (e: Exception) {&#10;                _uiState.update { &#10;                    it.copy(&#10;                        isLoadingEvents = false,&#10;                        error = &quot;Erro ao carregar eventos: ${e.message}&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun toggleFollow() {&#10;        viewModelScope.launch {&#10;            val profileUser = _uiState.value.user ?: return@launch&#10;            val currentUser = auth.currentUser ?: return@launch&#10;&#10;            val isCurrentlyFollowing = _uiState.value.isFollowing&#10;&#10;            try {&#10;                // 1. Atualizar o estado UI imediatamente para feedback instantâneo&#10;                val updatedFollowersList = profileUser.followers.toMutableList()&#10;                &#10;                if (isCurrentlyFollowing) {&#10;                    updatedFollowersList.remove(currentUser.uid)&#10;                } else {&#10;                    updatedFollowersList.add(currentUser.uid)&#10;                }&#10;                &#10;                // Criar uma cópia atualizada do user com a nova lista de seguidores&#10;                val updatedUser = profileUser.copy(followers = updatedFollowersList)&#10;                &#10;                // Atualizar o estado com o user modificado e o novo status de isFollowing&#10;                _uiState.update { &#10;                    it.copy(&#10;                        user = updatedUser,&#10;                        isFollowing = !isCurrentlyFollowing&#10;                    ) &#10;                }&#10;&#10;                // 2. Persistir as mudanças no Firestore&#10;                val currentUserRef = db.collection(&quot;users&quot;).document(currentUser.uid)&#10;                val profileUserRef = db.collection(&quot;users&quot;).document(profileUser.uid)&#10;&#10;                if (isCurrentlyFollowing) {&#10;                    currentUserRef.update(&quot;following&quot;, FieldValue.arrayRemove(profileUser.uid))&#10;                    profileUserRef.update(&quot;followers&quot;, FieldValue.arrayRemove(currentUser.uid))&#10;                } else {&#10;                    currentUserRef.update(&quot;following&quot;, FieldValue.arrayUnion(profileUser.uid))&#10;                    profileUserRef.update(&quot;followers&quot;, FieldValue.arrayUnion(currentUser.uid))&#10;                }&#10;            } catch(e: Exception) {&#10;                // Em caso de erro, reverter para o estado anterior&#10;                _uiState.update { it.copy(isFollowing = isCurrentlyFollowing, error = &quot;Ocorreu um erro ao atualizar.&quot;) }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/user/UserCreatedEventList.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/user/UserCreatedEventList.kt" />
              <option name="originalContent" value="package com.pdm.zone.ui.screens.user&#10;&#10;import android.R.attr.navigationIcon&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.LocationOn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.navigation.NavHostController&#10;import coil.compose.AsyncImage&#10;import coil.request.ImageRequest&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.pdm.zone.R&#10;import com.pdm.zone.data.model.Event&#10;import com.pdm.zone.ui.theme.Primary&#10;import kotlinx.coroutines.tasks.await&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun UserCreatedEventList(&#10;    username: String?,&#10;    modifier: Modifier = Modifier,&#10;    navController: NavHostController,&#10;    onClick: (String) -&gt; Unit&#10;)&#10;{&#10;    val db = FirebaseFirestore.getInstance()&#10;    var events by remember { mutableStateOf&lt;List&lt;Event&gt;&gt;(emptyList()) }&#10;    var isLoading by remember { mutableStateOf(true) }&#10;    val dateFormatter = remember { SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale(&quot;pt&quot;, &quot;BR&quot;)) }&#10;&#10;    LaunchedEffect(username) {&#10;        if (username != null) {&#10;            try {&#10;                val result = db.collection(&quot;events&quot;)&#10;                    .whereEqualTo(&quot;creatorUsername&quot;, username)&#10;                    .get()&#10;                    .await()&#10;&#10;                events = result.toObjects(Event::class.java)&#10;            } catch (e: Exception) {&#10;                e.printStackTrace()&#10;            } finally {&#10;                isLoading = false&#10;            }&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Eventos de $username&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = { navController.popBackStack() }) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Voltar&quot;,&#10;                            tint = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { padding -&gt;&#10;        Box(modifier = Modifier.padding(padding)) {&#10;            when {&#10;                isLoading -&gt; CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))&#10;                events.isEmpty() -&gt; Text(&quot;Nenhum evento encontrado.&quot;, modifier = Modifier.align(Alignment.Center))&#10;                else -&gt; LazyColumn(modifier = Modifier.fillMaxSize().padding(16.dp)) {&#10;                    items(events) { event -&gt;&#10;                        Card(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(vertical = 8.dp)&#10;                                .clickable { onClick(event.id) }&#10;                        ) {&#10;                            Row (&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(8.dp),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                // Imagem do evento&#10;                                AsyncImage(&#10;                                    model = ImageRequest.Builder(LocalContext.current)&#10;                                        .data(event.imageUrl)&#10;                                        .crossfade(true)&#10;                                        .build(),&#10;                                    placeholder = painterResource(R.drawable.placeholder_event),&#10;                                    contentDescription = event.title,&#10;                                    contentScale = ContentScale.Crop,&#10;                                    modifier = Modifier&#10;                                        .size(100.dp)&#10;                                        .padding(end = 8.dp)&#10;                                )&#10;&#10;                                // Detalhes do evento&#10;                                Column(&#10;                                    modifier = Modifier&#10;                                        .weight(1f)&#10;                                        .padding(start = 8.dp)&#10;                                ) {&#10;                                    // Título&#10;                                    Text(&#10;                                        text = event.title,&#10;                                        style = MaterialTheme.typography.titleMedium,&#10;                                        color = Primary,&#10;                                        fontWeight = FontWeight.Bold&#10;                                    )&#10;&#10;                                    // Local&#10;                                    Row(&#10;                                        verticalAlignment = Alignment.CenterVertically,&#10;                                        modifier = Modifier.padding(top = 4.dp)&#10;                                    ) {&#10;                                        Icon(&#10;                                            Icons.Default.LocationOn,&#10;                                            contentDescription = &quot;Local&quot;,&#10;                                            tint = Color.Gray,&#10;                                            modifier = Modifier.size(16.dp)&#10;                                        )&#10;                                        Spacer(modifier = Modifier.width(4.dp))&#10;                                        Text(&#10;                                            text = event.location,&#10;                                            style = MaterialTheme.typography.bodySmall,&#10;                                            color = Color.Gray&#10;                                        )&#10;                                    }&#10;&#10;                                    // Data&#10;                                    event.eventDate?.let { date -&gt;&#10;                                        Row(&#10;                                            verticalAlignment = Alignment.CenterVertically,&#10;                                            modifier = Modifier.padding(top = 4.dp)&#10;                                        ) {&#10;                                            Text(&#10;                                                text = &quot;Data:&quot;,&#10;                                                style = MaterialTheme.typography.bodySmall,&#10;                                                fontWeight = FontWeight.Bold,&#10;                                                color = Color.Gray&#10;                                            )&#10;                                            Spacer(modifier = Modifier.width(4.dp))&#10;                                            Text(&#10;                                                text = dateFormatter.format(date),&#10;                                                style = MaterialTheme.typography.bodySmall,&#10;                                                color = Color.Gray&#10;                                            )&#10;                                        }&#10;                                    }&#10;&#10;                                    // Horário&#10;                                    Row(&#10;                                        verticalAlignment = Alignment.CenterVertically,&#10;                                        modifier = Modifier.padding(top = 4.dp)&#10;                                    ) {&#10;                                        Text(&#10;                                            text = &quot;Horário:&quot;,&#10;                                            style = MaterialTheme.typography.bodySmall,&#10;                                            fontWeight = FontWeight.Bold,&#10;                                            color = Color.Gray&#10;                                        )&#10;                                        Spacer(modifier = Modifier.width(4.dp))&#10;                                        Text(&#10;                                            text = &quot;${event.startTime ?: &quot;--:--&quot;} - ${event.endTime ?: &quot;--:--&quot;}&quot;,&#10;                                            style = MaterialTheme.typography.bodySmall,&#10;                                            color = Color.Gray&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.pdm.zone.ui.screens.user&#10;&#10;import android.R.attr.navigationIcon&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.navigation.NavHostController&#10;import coil.compose.AsyncImage&#10;import coil.request.ImageRequest&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.pdm.zone.R&#10;import com.pdm.zone.data.model.Event&#10;import com.pdm.zone.ui.components.CompactEventCard&#10;import kotlinx.coroutines.tasks.await&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun UserCreatedEventList(&#10;    username: String?,&#10;    modifier: Modifier = Modifier,&#10;    navController: NavHostController,&#10;    onClick: (String) -&gt; Unit&#10;)&#10;{   &#10;    val db = FirebaseFirestore.getInstance()&#10;    var events by remember { mutableStateOf&lt;List&lt;Event&gt;&gt;(emptyList()) }&#10;    var isLoading by remember { mutableStateOf(true) }&#10;&#10;    LaunchedEffect(username) {&#10;        if (username != null) {&#10;            try {&#10;                val result = db.collection(&quot;events&quot;)&#10;                    .whereEqualTo(&quot;creatorUsername&quot;, username)&#10;                    .get()&#10;                    .await()&#10;&#10;                events = result.toObjects(Event::class.java)&#10;            } catch (e: Exception) {&#10;                e.printStackTrace()&#10;            } finally {&#10;                isLoading = false&#10;            }&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Eventos de $username&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = { navController.popBackStack() }) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Voltar&quot;,&#10;                            tint = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { padding -&gt;&#10;        Box(modifier = Modifier.padding(padding)) {&#10;            when {&#10;                isLoading -&gt; CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))&#10;                events.isEmpty() -&gt; Text(&quot;Nenhum evento encontrado.&quot;, modifier = Modifier.align(Alignment.Center))&#10;                else -&gt; LazyColumn(modifier = Modifier.fillMaxSize()) {&#10;                    items(events) { event -&gt;&#10;                        CompactEventCard(&#10;                            event = event,&#10;                            onCardClick = { &#10;                                onClick(it.id) &#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/user/UserProfile.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/user/UserProfile.kt" />
              <option name="originalContent" value="package com.pdm.zone.ui.screens.user&#10;&#10;import android.app.Activity&#10;import android.content.Intent&#10;import android.widget.Toast&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.material3.TabRowDefaults.tabIndicatorOffset&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavHostController&#10;import com.pdm.zone.data.model.User&#10;import com.pdm.zone.data.model.Event&#10;import com.pdm.zone.ui.theme.Primary&#10;import com.pdm.zone.ui.components.EventCard&#10;import coil.compose.AsyncImage&#10;import coil.request.ImageRequest&#10;import com.pdm.zone.R&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;@Composable&#10;fun ProfilePage(&#10;    navController: NavHostController,&#10;    username: String,&#10;    viewModel: ProfileViewModel = viewModel()&#10;) {&#10;&#10;    val uiState by viewModel.uiState.collectAsState()&#10;    val context = LocalContext.current&#10;&#10;    LaunchedEffect(username) {&#10;        viewModel.loadUserProfile(username)&#10;    }&#10;&#10;    LaunchedEffect(uiState.error) {&#10;        uiState.error?.let {&#10;            Toast.makeText(context, it, Toast.LENGTH_LONG).show()&#10;        }&#10;    }&#10;&#10;    if (uiState.isLoading) {&#10;        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#10;            CircularProgressIndicator()&#10;        }&#10;        return&#10;    }&#10;&#10;    if (uiState.user == null) {&#10;        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#10;            Text(uiState.error ?: &quot;Perfil não encontrado.&quot;)&#10;        }&#10;        return&#10;    }&#10;&#10;    val user = uiState.user!!&#10;    var selectedTab by remember { mutableStateOf(0) }&#10;    val tabs = listOf(&quot;Próximos eventos&quot;, &quot;Eventos passados&quot;)&#10;&#10;    LazyColumn(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color.White)&#10;    ) {&#10;        item { ProfileHeader(user) }&#10;        item { ProfileStats(user = user, navController = navController) }&#10;&#10;        if (uiState.isCurrentUserProfile) {&#10;            item { ProfileActions() }&#10;        } else {&#10;            item {&#10;                FollowActions(&#10;                    isFollowing = uiState.isFollowing,&#10;                    onClick = { viewModel.toggleFollow() }&#10;                )&#10;            }&#10;        }&#10;&#10;        item {&#10;            EventTabs(&#10;                selectedTab = selectedTab,&#10;                tabs = tabs,&#10;                onTabSelected = { selectedTab = it }&#10;            )&#10;        }&#10;&#10;        when (selectedTab) {&#10;            0 -&gt; {&#10;                if (uiState.isLoadingEvents) {&#10;                    item {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .height(200.dp),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            CircularProgressIndicator()&#10;                        }&#10;                    }&#10;                } else if (uiState.upcomingEvents.isEmpty()) {&#10;                    item {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .height(200.dp),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;Nenhum evento próximo&quot;,&#10;                                color = Color.Gray,&#10;                                fontSize = 16.sp&#10;                            )&#10;                        }&#10;                    }&#10;                } else {&#10;                    items(uiState.upcomingEvents) { event -&gt;&#10;                        EventCard(&#10;                            event = event,&#10;                            onCardClick = { navController.navigate(&quot;eventDetails/${it.id}&quot;) }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;            1 -&gt; {&#10;                if (uiState.isLoadingEvents) {&#10;                    item {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .height(200.dp),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            CircularProgressIndicator()&#10;                        }&#10;                    }&#10;                } else if (uiState.pastEvents.isEmpty()) {&#10;                    item {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .height(200.dp),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;Nenhum evento passado&quot;,&#10;                                color = Color.Gray,&#10;                                fontSize = 16.sp&#10;                            )&#10;                        }&#10;                    }&#10;                } else {&#10;                    items(uiState.pastEvents) { event -&gt;&#10;                        EventCard(&#10;                            event = event,&#10;                            onCardClick = { navController.navigate(&quot;eventDetails/${it.id}&quot;) }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ProfileStats(user: User, navController: NavHostController) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp, vertical = 8.dp),&#10;        horizontalArrangement = Arrangement.SpaceEvenly&#10;    ) {&#10;        StatItem(&#10;            count = user.following.size.toString(),&#10;            label = &quot;Seguindo&quot;,&#10;            onClick = {&#10;                navController.navigate(&quot;userList/seguindo/${user.username}&quot;)&#10;            }&#10;        )&#10;        StatItem(&#10;            count = user.followers.size.toString(),&#10;            label = &quot;Seguidores&quot;,&#10;            onClick = {&#10;                navController.navigate(&quot;userList/seguidores/${user.username}&quot;)&#10;            }&#10;        )&#10;        StatItem(&#10;            count = user.createdEvents.size.toString(),&#10;            label = &quot;Eventos criados&quot;,&#10;            onClick = {&#10;                navController.navigate(&quot;EventList/createdEvents/${user.username}&quot;)&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun FollowActions(&#10;    isFollowing: Boolean,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    Button(&#10;        onClick = onClick,&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp),&#10;        colors = ButtonDefaults.buttonColors(&#10;            containerColor = if (isFollowing) Color.Gray else Primary&#10;        ),&#10;        shape = RoundedCornerShape(8.dp)&#10;    ) {&#10;        Text(&#10;            text = if (isFollowing) &quot;Deixar de seguir&quot; else &quot;Seguir&quot;,&#10;            color = Color.White,&#10;            fontSize = 14.sp&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ProfileHeader(user: User) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(16.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        // Foto do perfil com fallback&#10;        Box(&#10;            modifier = Modifier&#10;                .size(120.dp)&#10;                .clip(CircleShape)&#10;                .background(Color.Gray.copy(alpha = 0.1f)),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            if (!user.profilePic.isNullOrBlank()) {&#10;                AsyncImage(&#10;                    model = ImageRequest.Builder(LocalContext.current)&#10;                        .data(user.profilePic)&#10;                        .crossfade(true)&#10;                        .build(),&#10;                    contentDescription = &quot;Foto do perfil&quot;,&#10;                    modifier = Modifier&#10;                        .size(120.dp)&#10;                        .clip(CircleShape)&#10;                )&#10;            } else {&#10;                Text(&#10;                    text = user.firstName.first().toString(),&#10;                    fontSize = 48.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = Color.Gray&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        Text(&#10;            text = &quot;${user.firstName} ${user.lastName}&quot;,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = Primary&#10;        )&#10;&#10;        Text(&#10;            text = user.username,&#10;            fontSize = 16.sp,&#10;            color = Color.Gray&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(12.dp))&#10;&#10;        Text(&#10;            text = user.biography ?: &quot;&quot;,&#10;            fontSize = 14.sp,&#10;            color = Color.Black,&#10;            textAlign = TextAlign.Center,&#10;            lineHeight = 20.sp&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun StatItem(count: String, label: String, onClick: (() -&gt; Unit)? = null) {&#10;    Column(&#10;        modifier = Modifier&#10;            .clickable(enabled = onClick != null) { onClick?.invoke() },&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        Text(&#10;            text = count,&#10;            fontSize = 20.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = Color.Black&#10;        )&#10;        Text(&#10;            text = label,&#10;            fontSize = 12.sp,&#10;            color = Color.Gray&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ProfileActions() {&#10;    val activity = LocalContext.current as? Activity&#10;&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp, vertical = 8.dp),&#10;        horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;    ) {&#10;        Button(&#10;            onClick = {&#10;                activity?.startActivity(Intent(activity, UserProfileEdit::class.java))&#10;            },&#10;            modifier = Modifier.weight(1f),&#10;            colors = ButtonDefaults.buttonColors(&#10;                containerColor = Primary&#10;            ),&#10;            shape = RoundedCornerShape(8.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;Editar Perfil&quot;,&#10;                color = Color.White,&#10;                fontSize = 14.sp&#10;            )&#10;        }&#10;&#10;        Button(&#10;            onClick = { /* Implementar compartilhamento */ },&#10;            modifier = Modifier.weight(1f),&#10;            colors = ButtonDefaults.buttonColors(&#10;                containerColor = Primary&#10;            ),&#10;            shape = RoundedCornerShape(8.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;Compartilhar perfil&quot;,&#10;                color = Color.White,&#10;                fontSize = 14.sp&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun EventTabs(&#10;    selectedTab: Int,&#10;    tabs: List&lt;String&gt;,&#10;    onTabSelected: (Int) -&gt; Unit&#10;) {&#10;    TabRow(&#10;        selectedTabIndex = selectedTab,&#10;        modifier = Modifier.fillMaxWidth(),&#10;        containerColor = Color.White,&#10;        contentColor = Primary,&#10;        indicator = { tabPositions -&gt;&#10;            TabRowDefaults.Indicator(&#10;                modifier = Modifier.tabIndicatorOffset(tabPositions[selectedTab]),&#10;                color = Primary&#10;            )&#10;        }&#10;    ) {&#10;        tabs.forEachIndexed { index, title -&gt;&#10;            Tab(&#10;                selected = selectedTab == index,&#10;                onClick = { onTabSelected(index) },&#10;                text = {&#10;                    Text(&#10;                        text = title,&#10;                        fontSize = 16.sp,&#10;                        fontWeight = if (selectedTab == index) FontWeight.Bold else FontWeight.Normal&#10;                    )&#10;                },&#10;                selectedContentColor = Primary,&#10;                unselectedContentColor = Color.Gray&#10;            )&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.pdm.zone.ui.screens.user&#10;&#10;import android.app.Activity&#10;import android.content.Intent&#10;import android.widget.Toast&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.material3.TabRowDefaults.tabIndicatorOffset&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavHostController&#10;import com.pdm.zone.data.model.User&#10;import com.pdm.zone.data.model.Event&#10;import com.pdm.zone.ui.theme.Primary&#10;import com.pdm.zone.ui.components.EventCard&#10;import com.pdm.zone.ui.components.CompactEventCard&#10;import coil.compose.AsyncImage&#10;import coil.request.ImageRequest&#10;import com.pdm.zone.R&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;@Composable&#10;fun ProfilePage(&#10;    navController: NavHostController,&#10;    username: String,&#10;    viewModel: ProfileViewModel = viewModel()&#10;) {&#10;&#10;    val uiState by viewModel.uiState.collectAsState()&#10;    val context = LocalContext.current&#10;&#10;    LaunchedEffect(username) {&#10;        viewModel.loadUserProfile(username)&#10;    }&#10;&#10;    LaunchedEffect(uiState.error) {&#10;        uiState.error?.let {&#10;            Toast.makeText(context, it, Toast.LENGTH_LONG).show()&#10;        }&#10;    }&#10;&#10;    if (uiState.isLoading) {&#10;        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#10;            CircularProgressIndicator()&#10;        }&#10;        return&#10;    }&#10;&#10;    if (uiState.user == null) {&#10;        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#10;            Text(uiState.error ?: &quot;Perfil não encontrado.&quot;)&#10;        }&#10;        return&#10;    }&#10;&#10;    val user = uiState.user!!&#10;    var selectedTab by remember { mutableStateOf(0) }&#10;    val tabs = listOf(&quot;Próximos eventos&quot;, &quot;Eventos passados&quot;)&#10;&#10;    LazyColumn(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color.White)&#10;    ) {&#10;        item { ProfileHeader(user) }&#10;        item { ProfileStats(user = user, navController = navController) }&#10;&#10;        if (uiState.isCurrentUserProfile) {&#10;            item { ProfileActions() }&#10;        } else {&#10;            item {&#10;                FollowActions(&#10;                    isFollowing = uiState.isFollowing,&#10;                    onClick = { viewModel.toggleFollow() }&#10;                )&#10;            }&#10;        }&#10;&#10;        item {&#10;            EventTabs(&#10;                selectedTab = selectedTab,&#10;                tabs = tabs,&#10;                onTabSelected = { selectedTab = it }&#10;            )&#10;        }&#10;&#10;        when (selectedTab) {&#10;            0 -&gt; {&#10;                if (uiState.isLoadingEvents) {&#10;                    item {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .height(200.dp),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            CircularProgressIndicator()&#10;                        }&#10;                    }&#10;                } else if (uiState.upcomingEvents.isEmpty()) {&#10;                    item {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .height(200.dp),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;Nenhum evento próximo&quot;,&#10;                                color = Color.Gray,&#10;                                fontSize = 16.sp&#10;                            )&#10;                        }&#10;                    }&#10;                } else {&#10;                    items(uiState.upcomingEvents) { event -&gt;&#10;                        CompactEventCard(&#10;                            event = event,&#10;                            onCardClick = { navController.navigate(&quot;eventDetails/${it.id}&quot;) }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;            1 -&gt; {&#10;                if (uiState.isLoadingEvents) {&#10;                    item {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .height(200.dp),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            CircularProgressIndicator()&#10;                        }&#10;                    }&#10;                } else if (uiState.pastEvents.isEmpty()) {&#10;                    item {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .height(200.dp),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;Nenhum evento passado&quot;,&#10;                                color = Color.Gray,&#10;                                fontSize = 16.sp&#10;                            )&#10;                        }&#10;                    }&#10;                } else {&#10;                    items(uiState.pastEvents) { event -&gt;&#10;                        CompactEventCard(&#10;                            event = event,&#10;                            onCardClick = { navController.navigate(&quot;eventDetails/${it.id}&quot;) }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ProfileStats(user: User, navController: NavHostController) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp, vertical = 8.dp),&#10;        horizontalArrangement = Arrangement.SpaceEvenly&#10;    ) {&#10;        StatItem(&#10;            count = user.following.size.toString(),&#10;            label = &quot;Seguindo&quot;,&#10;            onClick = {&#10;                navController.navigate(&quot;userList/seguindo/${user.username}&quot;)&#10;            }&#10;        )&#10;        StatItem(&#10;            count = user.followers.size.toString(),&#10;            label = &quot;Seguidores&quot;,&#10;            onClick = {&#10;                navController.navigate(&quot;userList/seguidores/${user.username}&quot;)&#10;            }&#10;        )&#10;        StatItem(&#10;            count = user.createdEvents.size.toString(),&#10;            label = &quot;Eventos criados&quot;,&#10;            onClick = {&#10;                navController.navigate(&quot;EventList/createdEvents/${user.username}&quot;)&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun FollowActions(&#10;    isFollowing: Boolean,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    Button(&#10;        onClick = onClick,&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp),&#10;        colors = ButtonDefaults.buttonColors(&#10;            containerColor = if (isFollowing) Color.Gray else Primary&#10;        ),&#10;        shape = RoundedCornerShape(8.dp)&#10;    ) {&#10;        Text(&#10;            text = if (isFollowing) &quot;Deixar de seguir&quot; else &quot;Seguir&quot;,&#10;            color = Color.White,&#10;            fontSize = 14.sp&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ProfileHeader(user: User) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(16.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        // Foto do perfil com fallback&#10;        Box(&#10;            modifier = Modifier&#10;                .size(120.dp)&#10;                .clip(CircleShape)&#10;                .background(Color.Gray.copy(alpha = 0.1f)),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            if (!user.profilePic.isNullOrBlank()) {&#10;                AsyncImage(&#10;                    model = ImageRequest.Builder(LocalContext.current)&#10;                        .data(user.profilePic)&#10;                        .crossfade(true)&#10;                        .build(),&#10;                    contentDescription = &quot;Foto do perfil&quot;,&#10;                    modifier = Modifier&#10;                        .size(120.dp)&#10;                        .clip(CircleShape)&#10;                )&#10;            } else {&#10;                Text(&#10;                    text = user.firstName.first().toString(),&#10;                    fontSize = 48.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = Color.Gray&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        Text(&#10;            text = &quot;${user.firstName} ${user.lastName}&quot;,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = Primary&#10;        )&#10;&#10;        Text(&#10;            text = user.username,&#10;            fontSize = 16.sp,&#10;            color = Color.Gray&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(12.dp))&#10;&#10;        Text(&#10;            text = user.biography ?: &quot;&quot;,&#10;            fontSize = 14.sp,&#10;            color = Color.Black,&#10;            textAlign = TextAlign.Center,&#10;            lineHeight = 20.sp&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun StatItem(count: String, label: String, onClick: (() -&gt; Unit)? = null) {&#10;    Column(&#10;        modifier = Modifier&#10;            .clickable(enabled = onClick != null) { onClick?.invoke() },&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        Text(&#10;            text = count,&#10;            fontSize = 20.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = Color.Black&#10;        )&#10;        Text(&#10;            text = label,&#10;            fontSize = 12.sp,&#10;            color = Color.Gray&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ProfileActions() {&#10;    val activity = LocalContext.current as? Activity&#10;&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp, vertical = 8.dp),&#10;        horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;    ) {&#10;        Button(&#10;            onClick = {&#10;                activity?.startActivity(Intent(activity, UserProfileEdit::class.java))&#10;            },&#10;            modifier = Modifier.weight(1f),&#10;            colors = ButtonDefaults.buttonColors(&#10;                containerColor = Primary&#10;            ),&#10;            shape = RoundedCornerShape(8.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;Editar Perfil&quot;,&#10;                color = Color.White,&#10;                fontSize = 14.sp&#10;            )&#10;        }&#10;&#10;        Button(&#10;            onClick = { /* Implementar compartilhamento */ },&#10;            modifier = Modifier.weight(1f),&#10;            colors = ButtonDefaults.buttonColors(&#10;                containerColor = Primary&#10;            ),&#10;            shape = RoundedCornerShape(8.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;Compartilhar perfil&quot;,&#10;                color = Color.White,&#10;                fontSize = 14.sp&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun EventTabs(&#10;    selectedTab: Int,&#10;    tabs: List&lt;String&gt;,&#10;    onTabSelected: (Int) -&gt; Unit&#10;) {&#10;    TabRow(&#10;        selectedTabIndex = selectedTab,&#10;        modifier = Modifier.fillMaxWidth(),&#10;        containerColor = Color.White,&#10;        contentColor = Primary,&#10;        indicator = { tabPositions -&gt;&#10;            TabRowDefaults.Indicator(&#10;                modifier = Modifier.tabIndicatorOffset(tabPositions[selectedTab]),&#10;                color = Primary&#10;            )&#10;        }&#10;    ) {&#10;        tabs.forEachIndexed { index, title -&gt;&#10;            Tab(&#10;                selected = selectedTab == index,&#10;                onClick = { onTabSelected(index) },&#10;                text = {&#10;                    Text(&#10;                        text = title,&#10;                        fontSize = 16.sp,&#10;                        fontWeight = if (selectedTab == index) FontWeight.Bold else FontWeight.Normal&#10;                    )&#10;                },&#10;                selectedContentColor = Primary,&#10;                unselectedContentColor = Color.Gray&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>