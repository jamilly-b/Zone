<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.Zone&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.ui.screens.home.Home&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:label=&quot;@string/title_activity_home&quot;&#10;            android:theme=&quot;@style/Theme.Zone&quot; /&gt;&#10;        &lt;activity&#10;            android:name=&quot;.ui.screens.login.LoginActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/title_activity_login&quot;&#10;            android:theme=&quot;@style/Theme.Zone&quot; /&gt;&#10;        &lt;activity&#10;            android:name=&quot;.ui.screens.login.RegisterActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:label=&quot;@string/title_activity_register&quot;&#10;            android:theme=&quot;@style/Theme.Zone&quot; /&gt;&#10;        &lt;activity&#10;            android:name=&quot;.ui.screens.user.UserProfileEdit&quot; /&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:theme=&quot;@style/Theme.Zone&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.Zone&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.ui.screens.home.Home&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:label=&quot;@string/title_activity_home&quot;&#10;            android:theme=&quot;@style/Theme.Zone&quot; /&gt;&#10;        &lt;activity&#10;            android:name=&quot;.ui.screens.login.LoginActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/title_activity_login&quot;&#10;            android:theme=&quot;@style/Theme.Zone&quot; /&gt;&#10;        &lt;activity&#10;            android:name=&quot;.ui.screens.login.RegisterActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:label=&quot;@string/title_activity_register&quot;&#10;            android:theme=&quot;@style/Theme.Zone&quot; /&gt;&#10;        &lt;activity&#10;            android:name=&quot;.ui.screens.user.UserProfileEdit&quot; /&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:theme=&quot;@style/Theme.Zone&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/MainActivity.kt" />
              <option name="originalContent" value="package com.pdm.zone&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.navigation.compose.rememberNavController&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.pdm.zone.data.SessionManager&#10;import com.pdm.zone.ui.nav.MainDrawer&#10;import com.pdm.zone.ui.nav.BottomNavBar&#10;import com.pdm.zone.ui.nav.BottomNavItem&#10;import com.pdm.zone.ui.nav.MainDrawer&#10;import com.pdm.zone.ui.nav.MainNavHost&#10;import com.pdm.zone.ui.screens.login.LoginActivity&#10;import com.pdm.zone.ui.theme.ZoneTheme&#10;&#10;class MainActivity : ComponentActivity() {&#10;    @OptIn(ExperimentalMaterial3Api::class)&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;&#10;        val currentUser = FirebaseAuth.getInstance().currentUser&#10;&#10;        if (currentUser == null) {&#10;            startActivity(Intent(this, LoginActivity::class.java))&#10;            finish()&#10;            return&#10;        }&#10;&#10;        setContent {&#10;            var isUserLoaded by remember { mutableStateOf(false) }&#10;&#10;            // Carrega os dados do usuário quando entrar na tela&#10;            LaunchedEffect(Unit) {&#10;                SessionManager.loadUserAfterLogin(currentUser.uid)&#10;                isUserLoaded = true&#10;            }&#10;&#10;            // Enquanto não carregar os dados, mostra uma tela de loading&#10;            if (!isUserLoaded) {&#10;                ZoneTheme {&#10;                    Box(modifier = Modifier.fillMaxSize()) {&#10;                        CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))&#10;                    }&#10;                }&#10;            } else {&#10;                val navController = rememberNavController()&#10;                ZoneTheme {&#10;                    Scaffold(&#10;                        bottomBar = {&#10;                            val items = listOf(&#10;                                BottomNavItem.HomeButton,&#10;                                BottomNavItem.ProfileButton,&#10;                            )&#10;                            BottomNavBar(navController = navController, items = items)&#10;                        },&#10;                        floatingActionButton = {&#10;                            FloatingActionButton(onClick = {&#10;                                navController.navigate(&quot;eventRegister&quot;)&#10;                            }) {&#10;                                Icon(Icons.Default.Add, contentDescription = &quot;Adicionar&quot;)&#10;                            }&#10;                        }&#10;                    ) { innerPadding -&gt;&#10;                        Box(modifier = Modifier.padding(innerPadding)) {&#10;                            MainNavHost(navController = navController)&#10;                        }&#10;                    }                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.pdm.zone&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.navigation.compose.rememberNavController&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.pdm.zone.data.SessionManager&#10;import com.pdm.zone.ui.nav.MainDrawer&#10;import com.pdm.zone.ui.nav.BottomNavBar&#10;import com.pdm.zone.ui.nav.BottomNavItem&#10;import com.pdm.zone.ui.nav.MainDrawer&#10;import com.pdm.zone.ui.nav.MainNavHost&#10;import com.pdm.zone.ui.screens.login.LoginActivity&#10;import com.pdm.zone.ui.theme.ZoneTheme&#10;&#10;class MainActivity : ComponentActivity() {&#10;    @OptIn(ExperimentalMaterial3Api::class)&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;&#10;        val currentUser = FirebaseAuth.getInstance().currentUser&#10;&#10;        if (currentUser == null) {&#10;            startActivity(Intent(this, LoginActivity::class.java))&#10;            finish()&#10;            return&#10;        }&#10;&#10;        setContent {&#10;            var isUserLoaded by remember { mutableStateOf(false) }&#10;&#10;            // Carrega os dados do usuário quando entrar na tela&#10;            LaunchedEffect(Unit) {&#10;                SessionManager.loadUserAfterLogin(currentUser.uid)&#10;                isUserLoaded = true&#10;            }&#10;&#10;            // Enquanto não carregar os dados, mostra uma tela de loading&#10;            if (!isUserLoaded) {&#10;                ZoneTheme {&#10;                    Box(modifier = Modifier.fillMaxSize()) {&#10;                        CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))&#10;                    }&#10;                }&#10;            } else {&#10;                val navController = rememberNavController()&#10;                ZoneTheme {&#10;                    Scaffold(&#10;                        bottomBar = {&#10;                            val items = listOf(&#10;                                BottomNavItem.HomeButton,&#10;                                BottomNavItem.SearchButton, // novo item de pesquisa&#10;                                BottomNavItem.ListButton,&#10;                                BottomNavItem.ProfileButton,&#10;                            )&#10;                            BottomNavBar(navController = navController, items = items)&#10;                        },&#10;                        floatingActionButton = {&#10;                            FloatingActionButton(onClick = {&#10;                                navController.navigate(&quot;eventRegister&quot;)&#10;                            }) {&#10;                                Icon(Icons.Default.Add, contentDescription = &quot;Adicionar&quot;)&#10;                            }&#10;                        }&#10;                    ) { innerPadding -&gt;&#10;                        Box(modifier = Modifier.padding(innerPadding)) {&#10;                            MainNavHost(navController = navController)&#10;                        }&#10;                    }                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/data/model/Event.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/data/model/Event.kt" />
              <option name="originalContent" value="package com.pdm.zone.data.model&#10;&#10;import com.google.firebase.firestore.DocumentId&#10;import com.google.firebase.firestore.Exclude&#10;import com.google.firebase.firestore.PropertyName&#10;import com.google.firebase.firestore.ServerTimestamp&#10;import java.util.Date&#10;&#10;data class Event(&#10;    @DocumentId&#10;    var id: String = &quot;&quot;,&#10;    var title: String = &quot;&quot;,&#10;    var description: String = &quot;&quot;,&#10;    var location: String = &quot;&quot;,&#10;    var category: EventCategory = EventCategory.FESTAS,&#10;    var imageUrl: String? = null,&#10;    var creatorId: String = &quot;&quot;,&#10;    var creatorUsername: String = &quot;&quot;,&#10;&#10;    // Campos de data e hora&#10;    @ServerTimestamp&#10;    var eventDate: Date? = null,&#10;    var startTime: String? = null,&#10;    var endTime: String? = null,&#10;&#10;    var attendees: List&lt;String&gt; = emptyList(),&#10;    var interestedUsers: List&lt;String&gt; = emptyList(),&#10;&#10;    // Adicionamos estas propriedades com PropertyName para que o Firestore as reconheça&#10;    // mesmo sendo campos calculados no lado do cliente&#10;    @get:PropertyName(&quot;confirmedCount&quot;)&#10;    @PropertyName(&quot;confirmedCount&quot;)&#10;    var _confirmedCount: Int = 0,&#10;&#10;    @get:PropertyName(&quot;interestedCount&quot;)&#10;    @PropertyName(&quot;interestedCount&quot;)&#10;    var _interestedCount: Int = 0&#10;) {&#10;    constructor() : this(&#10;        id = &quot;&quot;,&#10;        title = &quot;&quot;,&#10;        description = &quot;&quot;,&#10;        location = &quot;&quot;,&#10;        category = EventCategory.FESTAS,&#10;        imageUrl = null,&#10;        creatorId = &quot;&quot;,&#10;        creatorUsername = &quot;&quot;,&#10;        eventDate = null,&#10;        startTime = null,&#10;        endTime = null,&#10;        attendees = emptyList(),&#10;        interestedUsers = emptyList()&#10;    )&#10;&#10;    // Propriedades calculadas&#10;    @get:Exclude  // Excluir do Firestore, pois usamos os campos _confirmedCount e _interestedCount para serialização&#10;    val confirmedCount: Int&#10;        get() = attendees.size&#10;&#10;    @get:Exclude  // Excluir do Firestore, pois usamos os campos _interestedCount e _interestedCount para serialização&#10;    val interestedCount: Int&#10;        get() = interestedUsers.size&#10;}" />
              <option name="updatedContent" value="package com.pdm.zone.data.model&#10;&#10;import com.google.firebase.firestore.DocumentId&#10;import com.google.firebase.firestore.Exclude&#10;import com.google.firebase.firestore.PropertyName&#10;import com.google.firebase.firestore.ServerTimestamp&#10;import java.util.Date&#10;&#10;data class Event(&#10;    @DocumentId&#10;    var id: String = &quot;&quot;,&#10;    var title: String = &quot;&quot;,&#10;    var description: String = &quot;&quot;,&#10;    var location: String = &quot;&quot;,&#10;    var category: EventCategory = EventCategory.FESTAS,&#10;    var imageUrl: String? = null,&#10;    var creatorId: String = &quot;&quot;,&#10;    var creatorUsername: String = &quot;&quot;,&#10;&#10;    // NOVOS CAMPOS GEO&#10;    var placeId: String? = null,&#10;    var latitude: Double? = null,&#10;    var longitude: Double? = null,&#10;    var address: String? = null,&#10;&#10;    // Campos de data e hora&#10;    @ServerTimestamp&#10;    var eventDate: Date? = null,&#10;    var startTime: String? = null,&#10;    var endTime: String? = null,&#10;&#10;    var attendees: List&lt;String&gt; = emptyList(),&#10;    var interestedUsers: List&lt;String&gt; = emptyList(),&#10;&#10;    // Adicionamos estas propriedades com PropertyName para que o Firestore as reconheça&#10;    // mesmo sendo campos calculados no lado do cliente&#10;    @get:PropertyName(&quot;confirmedCount&quot;)&#10;    @PropertyName(&quot;confirmedCount&quot;)&#10;    var _confirmedCount: Int = 0,&#10;&#10;    @get:PropertyName(&quot;interestedCount&quot;)&#10;    @PropertyName(&quot;interestedCount&quot;)&#10;    var _interestedCount: Int = 0&#10;) {&#10;    constructor() : this(&#10;        id = &quot;&quot;,&#10;        title = &quot;&quot;,&#10;        description = &quot;&quot;,&#10;        location = &quot;&quot;,&#10;        category = EventCategory.FESTAS,&#10;        imageUrl = null,&#10;        creatorId = &quot;&quot;,&#10;        creatorUsername = &quot;&quot;,&#10;        placeId = null,&#10;        latitude = null,&#10;        longitude = null,&#10;        address = null,&#10;        eventDate = null,&#10;        startTime = null,&#10;        endTime = null,&#10;        attendees = emptyList(),&#10;        interestedUsers = emptyList()&#10;    )&#10;&#10;    // Propriedades calculadas&#10;    @get:Exclude  // Excluir do Firestore, pois usamos os campos _confirmedCount e _interestedCount para serialização&#10;    val confirmedCount: Int&#10;        get() = attendees.size&#10;&#10;    @get:Exclude  // Excluir do Firestore, pois usamos os campos _interestedCount e _interestedCount para serialização&#10;    val interestedCount: Int&#10;        get() = interestedUsers.size&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/components/CompactEventCard.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/components/CompactEventCard.kt" />
              <option name="updatedContent" value="package com.pdm.zone.ui.components&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.LocationOn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import coil.compose.AsyncImage&#10;import coil.request.ImageRequest&#10;import com.pdm.zone.R&#10;import com.pdm.zone.data.model.Event&#10;import com.pdm.zone.ui.theme.Primary&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;/**&#10; * Uma versão compacta do card de evento que exibe a imagem à esquerda e informações à direita&#10; * Usado nas telas de Eventos Confirmados e Eventos Criados pelo usuário&#10; */&#10;@Composable&#10;fun CompactEventCard(&#10;    event: Event,&#10;    onCardClick: (Event) -&gt; Unit = {}&#10;) {&#10;    val dateFormatter = remember { SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale(&quot;pt&quot;, &quot;BR&quot;)) }&#10;    &#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 8.dp, horizontal = 16.dp),&#10;        shape = RoundedCornerShape(8.dp),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp),&#10;        onClick = { onCardClick(event) }&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(8.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Imagem do evento&#10;            AsyncImage(&#10;                model = ImageRequest.Builder(LocalContext.current)&#10;                    .data(event.imageUrl)&#10;                    .crossfade(true)&#10;                    .build(),&#10;                placeholder = painterResource(R.drawable.placeholder_event),&#10;                contentDescription = event.title,&#10;                contentScale = ContentScale.Crop,&#10;                modifier = Modifier&#10;                    .size(100.dp)&#10;                    .clip(RoundedCornerShape(8.dp))&#10;            )&#10;&#10;            // Detalhes do evento&#10;            Column(&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .padding(start = 12.dp)&#10;            ) {&#10;                // Título&#10;                Text(&#10;                    text = event.title,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = Primary,&#10;                    fontWeight = FontWeight.Bold,&#10;                    maxLines = 2,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;&#10;                // Local&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    modifier = Modifier.padding(top = 4.dp)&#10;                ) {&#10;                    Icon(&#10;                        Icons.Default.LocationOn,&#10;                        contentDescription = &quot;Local&quot;,&#10;                        tint = Color.Gray,&#10;                        modifier = Modifier.size(16.dp)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(4.dp))&#10;                    Text(&#10;                        text = event.location,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = Color.Gray,&#10;                        maxLines = 1,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;                }&#10;&#10;                // Data&#10;                event.eventDate?.let { date -&gt;&#10;                    Row(&#10;                        verticalAlignment = Alignment.CenterVertically,&#10;                        modifier = Modifier.padding(top = 4.dp)&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;Data:&quot;,&#10;                            style = MaterialTheme.typography.bodySmall,&#10;                            fontWeight = FontWeight.Bold,&#10;                            color = Color.Gray&#10;                        )&#10;                        Spacer(modifier = Modifier.width(4.dp))&#10;                        Text(&#10;                            text = dateFormatter.format(date),&#10;                            style = MaterialTheme.typography.bodySmall,&#10;                            color = Color.Gray&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Horário&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically,&#10;                    modifier = Modifier.padding(top = 4.dp)&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Horário:&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = Color.Gray&#10;                    )&#10;                    Spacer(modifier = Modifier.width(4.dp))&#10;                    Text(&#10;                        text = &quot;${event.startTime ?: &quot;--:--&quot;} - ${event.endTime ?: &quot;--:--&quot;}&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = Color.Gray&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/nav/BottomNavItem.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/nav/BottomNavItem.kt" />
              <option name="originalContent" value="package com.pdm.zone.ui.nav&#10;&#10;import android.net.http.SslCertificate.restoreState&#10;import android.net.http.SslCertificate.saveState&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Favorite&#10;import androidx.compose.material.icons.filled.Home&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material3.NavigationBar&#10;import androidx.compose.material3.NavigationBarItem&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.unit.sp&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;import com.pdm.zone.ui.theme.Primary&#10;import kotlinx.serialization.Serializable&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import com.google.firebase.Firebase&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.firestore&#10;import com.pdm.zone.data.SessionManager&#10;&#10;sealed interface Route {&#10;    @Serializable&#10;    data object Home : Route&#10;    @Serializable&#10;    data object List : Route&#10;    @Serializable&#10;    data object Profile : Route&#10;}&#10;    val title: String,&#10;    val icon: ImageVector,&#10;    val route: Route&#10;) {&#10;    data object HomeButton :&#10;        BottomNavItem(&quot;Início&quot;, Icons.Default.Home, Route.Home)&#10;&#10;    data object ListButton :&#10;        BottomNavItem(&quot;Próximos eventos&quot;, Icons.Default.Favorite, Route.List)&#10;&#10;    data object ProfileButton :&#10;@Composable&#10;fun BottomNavBar(&#10;    navController: NavHostController,&#10;    items: List&lt;BottomNavItem&gt;&#10;    // 1. Removido o parâmetro 'currentUserId', que não é mais necessário&#10;) {&#10;    // 2. Usando o SessionManager como única fonte para o usuário logado.&#10;    val currentUser by SessionManager.currentUser.collectAsState()&#10;&#10;    NavigationBar(contentColor = Primary) {&#10;        val navBackStackEntry by navController.currentBackStackEntryAsState()&#10;        val currentRoute = navBackStackEntry?.destination?.route&#10;&#10;        // 3. O LaunchedEffect antigo foi completamente REMOVIDO daqui.&#10;&#10;        items.forEach { item -&gt;&#10;            NavigationBarItem(&#10;                icon = { Icon(imageVector = item.icon, contentDescription = item.title) },&#10;                label = { Text(text = item.title, fontSize = 12.sp) },&#10;                alwaysShowLabel = true,&#10;                selected = when (item) {&#10;                    // Compara a rota atual com a rota de perfil, usando o username do SessionManager&#10;                    is BottomNavItem.ProfileButton -&gt; currentRoute == &quot;profile/${currentUser?.username}&quot;&#10;                    // Compara outras rotas pelo seu nome de classe qualificado&#10;                    else -&gt; currentRoute == item.route::class.qualifiedName&#10;                },&#10;                // 4. Lógica de clique TOTALMENTE CORRIGIDA&#10;                onClick = {&#10;                    when (item.route) {&#10;                        is Route.Profile -&gt; {&#10;                            // Ação para o perfil: só navega se tiver um username&#10;                            currentUser?.username?.let { username -&gt;&#10;                                navController.navigate(&quot;profile/$username&quot;) {&#10;                                    // Comportamento padrão para itens da bottom bar&#10;                                    popUpTo(navController.graph.startDestinationId) {&#10;                                        saveState = true&#10;                                    }&#10;                                    launchSingleTop = true&#10;                                    restoreState = true&#10;                                }&#10;                            }&#10;                        }&#10;                        else -&gt; {&#10;                            // Ação para outros itens (Home, List)&#10;                            navController.navigate(item.route) {&#10;                                // Comportamento padrão para itens da bottom bar&#10;                                popUpTo(navController.graph.startDestinationId) {&#10;                                    saveState = true&#10;                                }&#10;                                launchSingleTop = true&#10;                                restoreState = true&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.pdm.zone.ui.nav&#10;&#10;import android.net.http.SslCertificate.restoreState&#10;import android.net.http.SslCertificate.saveState&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Favorite&#10;import androidx.compose.material.icons.filled.Home&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material.icons.filled.Search&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.NavigationBar&#10;import androidx.compose.material3.NavigationBarItem&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.unit.sp&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;import com.pdm.zone.ui.theme.Primary&#10;import kotlinx.serialization.Serializable&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import com.google.firebase.Firebase&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.firestore&#10;import com.pdm.zone.data.SessionManager&#10;&#10;sealed interface Route {&#10;    @Serializable&#10;    data object Home : Route&#10;    @Serializable&#10;    data object List : Route&#10;    @Serializable&#10;    data object Profile : Route&#10;    @Serializable&#10;    data object Search : Route // nova rota de pesquisa&#10;}&#10;&#10;sealed class BottomNavItem(&#10;    val title: String,&#10;    val icon: ImageVector,&#10;    val route: Route&#10;) {&#10;    data object HomeButton :&#10;        BottomNavItem(&quot;Início&quot;, Icons.Default.Home, Route.Home)&#10;&#10;    data object SearchButton :&#10;        BottomNavItem(&quot;Pesquisar&quot;, Icons.Default.Search, Route.Search) // novo botão&#10;&#10;    data object ListButton :&#10;        BottomNavItem(&quot;Próximos eventos&quot;, Icons.Default.Favorite, Route.List)&#10;&#10;    data object ProfileButton :&#10;        BottomNavItem(&quot;Perfil&quot;, Icons.Default.Person, Route.Profile)&#10;}&#10;&#10;@Composable&#10;fun BottomNavBar(&#10;    navController: NavHostController,&#10;    items: List&lt;BottomNavItem&gt;&#10;    // 1. Removido o parâmetro 'currentUserId', que não é mais necessário&#10;) {&#10;    // 2. Usando o SessionManager como única fonte para o usuário logado.&#10;    val currentUser by SessionManager.currentUser.collectAsState()&#10;&#10;    NavigationBar(contentColor = Primary) {&#10;        val navBackStackEntry by navController.currentBackStackEntryAsState()&#10;        val currentRoute = navBackStackEntry?.destination?.route&#10;&#10;        // 3. O LaunchedEffect antigo foi completamente REMOVIDO daqui.&#10;&#10;        items.forEach { item -&gt;&#10;            NavigationBarItem(&#10;                icon = { Icon(imageVector = item.icon, contentDescription = item.title) },&#10;                label = { Text(text = item.title, fontSize = 12.sp) },&#10;                alwaysShowLabel = true,&#10;                selected = when (item) {&#10;                    // Compara a rota atual com a rota de perfil, usando o username do SessionManager&#10;                    is BottomNavItem.ProfileButton -&gt; currentRoute == &quot;profile/${currentUser?.username}&quot;&#10;                    // Compara outras rotas pelo seu nome de classe qualificado&#10;                    else -&gt; currentRoute == item.route::class.qualifiedName&#10;                },&#10;                // 4. Lógica de clique TOTALMENTE CORRIGIDA&#10;                onClick = {&#10;                    when (item.route) {&#10;                        is Route.Profile -&gt; {&#10;                            // Ação para o perfil: só navega se tiver um username&#10;                            currentUser?.username?.let { username -&gt;&#10;                                navController.navigate(&quot;profile/$username&quot;) {&#10;                                    // Comportamento padrão para itens da bottom bar&#10;                                    popUpTo(navController.graph.startDestinationId) {&#10;                                        saveState = true&#10;                                    }&#10;                                    launchSingleTop = true&#10;                                    restoreState = true&#10;                                }&#10;                            }&#10;                        }&#10;                        else -&gt; {&#10;                            // Ação para outros itens (Home, List)&#10;                            navController.navigate(item.route) {&#10;                                // Comportamento padrão para itens da bottom bar&#10;                                popUpTo(navController.graph.startDestinationId) {&#10;                                    saveState = true&#10;                                }&#10;                                launchSingleTop = true&#10;                                restoreState = true&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/event/EventDetails.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/event/EventDetails.kt" />
              <option name="originalContent" value="package com.pdm.zone.ui.screens.event&#10;&#10;import android.content.Intent&#10;import android.net.Uri&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.DateRange&#10;import androidx.compose.material.icons.filled.Favorite&#10;import androidx.compose.material.icons.filled.FavoriteBorder&#10;import androidx.compose.material.icons.filled.LocationOn&#10;import androidx.compose.material.icons.filled.Star&#10;import androidx.compose.material.icons.outlined.Star&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavHostController&#10;import coil.compose.AsyncImage&#10;import coil.request.ImageRequest&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import com.google.android.gms.maps.MapView&#10;import com.google.android.gms.maps.CameraUpdateFactory&#10;import com.google.android.gms.maps.MapsInitializer&#10;import com.google.android.gms.maps.model.LatLng&#10;import com.google.android.gms.maps.model.MarkerOptions&#10;import com.pdm.zone.R&#10;import com.pdm.zone.data.model.Event&#10;import com.pdm.zone.ui.theme.Primary&#10;import com.pdm.zone.ui.theme.Secondary&#10;import java.text.SimpleDateFormat&#10;import java.util.Locale&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun EventDetailsPage (&#10;    eventId: String,&#10;    navController: NavHostController,&#10;    viewModel: EventDetailsViewModel = viewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsState()&#10;&#10;    LaunchedEffect(eventId) {&#10;        viewModel.loadEvent(eventId)&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Text(&#10;                        text = uiState.event?.title ?: &quot;&quot;,&#10;                        maxLines = 1,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = { navController.popBackStack() }) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Voltar&quot;,&#10;                            tint = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = Color.White&#10;                )&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .background(Color.White)&#10;        ) {&#10;            when {&#10;                uiState.isLoading -&gt; {&#10;                    CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))&#10;                }&#10;                uiState.error != null -&gt; {&#10;                    Text(&#10;                        text = uiState.error!!,&#10;                        modifier = Modifier.align(Alignment.Center),&#10;                        color = Color.Red&#10;                    )&#10;                }&#10;                uiState.event != null -&gt; {&#10;                    EventDetailsContent(&#10;                        event = uiState.event!!,&#10;                        isConfirmed = uiState.isCurrentUserConfirmed,&#10;                        isInterested = uiState.isCurrentUserInterested,&#10;                        onConfirmClick = { viewModel.togglePresenceConfirmation() },&#10;                        onInterestClick = { viewModel.toggleInterest() },&#10;                        navController = navController&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun EventDetailsContent(&#10;    event: Event,&#10;    isConfirmed: Boolean,&#10;    isInterested: Boolean,&#10;    onConfirmClick: () -&gt; Unit,&#10;    onInterestClick: () -&gt; Unit,&#10;    navController: NavHostController&#10;) {&#10;    LazyColumn(&#10;        modifier = Modifier.fillMaxSize()&#10;    ) {&#10;        item {&#10;            AsyncImage(&#10;                model = ImageRequest.Builder(LocalContext.current)&#10;                    .data(event.imageUrl)&#10;                    .crossfade(true)&#10;                    .build(),&#10;                placeholder = painterResource(R.drawable.placeholder_event),&#10;                contentDescription = event.title,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(250.dp),&#10;                contentScale = ContentScale.Crop&#10;            )&#10;        }&#10;&#10;        item {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = event.title,&#10;                    style = MaterialTheme.typography.headlineLarge,&#10;                    color = Primary,&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Row(horizontalArrangement = Arrangement.spacedBy(16.dp)) {&#10;                        Text(&#10;                            text = &quot;${event.confirmedCount} Confirmados&quot;,&#10;                            style = MaterialTheme.typography.bodySmall,&#10;                            color = Secondary,&#10;                            modifier = Modifier.clickable {&#10;                                navController.navigate(&quot;userList/confirmados/${event.id}&quot;)&#10;                            }&#10;                        )&#10;                        Text(&#10;                            text = &quot;${event.interestedCount} Interessados&quot;,&#10;                            style = MaterialTheme.typography.bodySmall,&#10;                            color = Color.Gray&#10;                        )&#10;                    }&#10;&#10;                    // ------------------ Ícones provisórios ------------------&#10;                    Row {&#10;                        IconButton(onClick = onInterestClick) {&#10;                            Icon(&#10;                                imageVector = if (isInterested) Icons.Default.Favorite else Icons.Default.FavoriteBorder,&#10;                                contentDescription = if (isInterested) &quot;Tenho Interesse&quot; else &quot;Remover dos Interesses&quot;,&#10;                                tint = if (isInterested) Primary else Color.Gray,&#10;                                modifier = Modifier.size(28.dp)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Button(&#10;                    onClick = onConfirmClick,&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = if (isConfirmed) Primary else Color.LightGray,&#10;                        contentColor = Color.White&#10;                    ),&#10;                    shape = RoundedCornerShape(50),&#10;                    contentPadding = PaddingValues(horizontal = 20.dp, vertical = 8.dp)&#10;                ) {&#10;                    Text(&quot;Eu vou&quot;)&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                Text(&#10;                    text = event.description,&#10;                    style = MaterialTheme.typography.bodyLarge,&#10;                    lineHeight = 22.sp&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(24.dp))&#10;                EventInfoSection(event = event)&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                Text(&#10;                    text = &quot;Criado por @${event.creatorUsername}&quot;,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = Primary,&#10;                    modifier = Modifier.clickable {&#10;                        navController.navigate(&quot;profile/${event.creatorUsername}&quot;)&#10;                    }&#10;                )&#10;                Spacer(modifier = Modifier.height(24.dp))&#10;                EventLocationMap(event)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun EventLocationMap(event: Event) {&#10;    val lat = event.latitude&#10;    val lng = event.longitude&#10;    val context = LocalContext.current&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .heightIn(min = 180.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;Localização&quot;,&#10;            style = MaterialTheme.typography.titleMedium,&#10;            color = Primary&#10;        )&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        if (lat != null &amp;&amp; lng != null) {&#10;            val mapView = remember { MapView(context) }&#10;            // Ciclo de vida simples (tela de detalhes)&#10;            DisposableEffect(Unit) {&#10;                mapView.onCreate(null)&#10;                mapView.onResume()&#10;                onDispose {&#10;                    mapView.onPause()&#10;                    mapView.onDestroy()&#10;                }&#10;            }&#10;            val target = remember(lat, lng) { LatLng(lat, lng) }&#10;            // Configure map once&#10;                val mapIntent = Intent(Intent.ACTION_VIEW, gmmIntentUri).apply { setPackage(&quot;com.google.android.apps.maps&quot;) }&#10;                if (mapIntent.resolveActivity(context.packageManager) == null) {&#10;                    context.startActivity(&#10;                        Intent(Intent.ACTION_VIEW, Uri.parse(&quot;https://www.google.com/maps/search/?api=1&amp;query=$lat,$lng&quot;))&#10;                    )&#10;                } else context.startActivity(mapIntent)&#10;            }&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(200.dp)&#10;                    .clip(RoundedCornerShape(12.dp))&#10;                    .clickable { openExternalMap() }&#10;            ) {&#10;                AndroidView(factory = { mapView }) { mView -&gt;&#10;                    // Add listeners after map ready&#10;                AndroidView(factory = { mv -&gt;&#10;                    MapsInitializer.initialize(context)&#10;                    mv.getMapAsync { googleMap -&gt;&#10;                        val target = LatLng(lat, lng)&#10;                        googleMap.uiSettings.isMapToolbarEnabled = false&#10;                        googleMap.moveCamera(CameraUpdateFactory.newLatLngZoom(target, 15f))&#10;                        googleMap.addMarker(&#10;                            MarkerOptions()&#10;                                .position(target)&#10;                                .title(event.title)&#10;                                .snippet(event.location)&#10;                        )&#10;                            openExternalMap(); true&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;            Text(&#10;                text = &quot;Toque para abrir no Google Maps&quot;,&#10;                style = MaterialTheme.typography.bodySmall,&#10;                color = Secondary&#10;            )&#10;        } else {&#10;            Text(&#10;                text = &quot;Localização não disponível&quot;,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = Color.Gray&#10;            )&#10;        }&#10;    }&#10;}&#10;                    mv&#10;                })&#10;@Composable&#10;fun EventInfoSection(event: Event) {&#10;    val dateFormatter = remember { SimpleDateFormat(&quot;dd 'de' MMMM&quot;, Locale(&quot;pt&quot;, &quot;BR&quot;)) }&#10;&#10;    Column(&#10;        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;    ) {&#10;        EventInfoItem(&#10;            icon = Icons.Default.LocationOn,&#10;            text = event.location&#10;        )&#10;&#10;        event.eventDate?.let { date -&gt;&#10;            val formattedDate = dateFormatter.format(date).replaceFirstChar { it.uppercase() }&#10;            val timeText = if (event.startTime != null &amp;&amp; event.endTime != null) {&#10;                &quot;$formattedDate | ${event.startTime} - ${event.endTime}&quot;&#10;            } else {&#10;                formattedDate&#10;            }&#10;            EventInfoItem(&#10;                icon = Icons.Default.DateRange,&#10;                text = timeText&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EventInfoItem(&#10;    icon: androidx.compose.ui.graphics.vector.ImageVector,&#10;    text: String&#10;) {&#10;    Row(&#10;        verticalAlignment = Alignment.CenterVertically,&#10;        horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;    ) {&#10;        Icon(&#10;            icon,&#10;            contentDescription = null,&#10;            tint = Color(0xFF8B5A96),&#10;            modifier = Modifier.size(20.dp)&#10;        )&#10;        Text(&#10;            text = text,&#10;            style = MaterialTheme.typography.bodyMedium&#10;        )&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.pdm.zone.ui.screens.event&#13;&#10;&#13;&#10;import android.content.Intent&#13;&#10;import android.net.Uri&#13;&#10;import android.util.Log&#13;&#10;import android.content.pm.PackageManager&#13;&#10;import androidx.compose.foundation.background&#13;&#10;import androidx.compose.foundation.clickable&#13;&#10;import androidx.compose.foundation.layout.*&#13;&#10;import androidx.compose.foundation.lazy.LazyColumn&#13;&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#13;&#10;import androidx.compose.material.icons.Icons&#13;&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#13;&#10;import androidx.compose.material.icons.filled.DateRange&#13;&#10;import androidx.compose.material.icons.filled.Favorite&#13;&#10;import androidx.compose.material.icons.filled.FavoriteBorder&#13;&#10;import androidx.compose.material.icons.filled.LocationOn&#13;&#10;import androidx.compose.material.icons.filled.Star&#13;&#10;import androidx.compose.material.icons.outlined.Star&#13;&#10;import androidx.compose.material3.*&#13;&#10;import androidx.compose.runtime.*&#13;&#10;import androidx.compose.ui.Alignment&#13;&#10;import androidx.compose.ui.Modifier&#13;&#10;import androidx.compose.ui.graphics.Color&#13;&#10;import androidx.compose.ui.layout.ContentScale&#13;&#10;import androidx.compose.ui.platform.LocalContext&#13;&#10;import androidx.compose.ui.res.painterResource&#13;&#10;import androidx.compose.ui.text.style.TextOverflow&#13;&#10;import androidx.compose.ui.unit.dp&#13;&#10;import androidx.compose.ui.unit.sp&#13;&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#13;&#10;import androidx.navigation.NavHostController&#13;&#10;import coil.compose.AsyncImage&#13;&#10;import coil.request.ImageRequest&#13;&#10;import androidx.compose.ui.viewinterop.AndroidView&#13;&#10;import com.google.android.gms.maps.MapView&#13;&#10;import com.google.android.gms.maps.CameraUpdateFactory&#13;&#10;import com.google.android.gms.maps.MapsInitializer&#13;&#10;import com.google.android.gms.maps.model.LatLng&#13;&#10;import com.google.android.gms.maps.model.MarkerOptions&#13;&#10;import com.pdm.zone.R&#13;&#10;import com.pdm.zone.data.model.Event&#13;&#10;import com.pdm.zone.ui.theme.Primary&#13;&#10;import com.pdm.zone.ui.theme.Secondary&#13;&#10;import java.text.SimpleDateFormat&#13;&#10;import java.util.Locale&#13;&#10;import androidx.compose.ui.draw.clip&#13;&#10;import com.google.android.gms.maps.GoogleMap&#13;&#10;&#13;&#10;@OptIn(ExperimentalMaterial3Api::class)&#13;&#10;@Composable&#13;&#10;fun EventDetailsPage (&#13;&#10;    eventId: String,&#13;&#10;    navController: NavHostController,&#13;&#10;    viewModel: EventDetailsViewModel = viewModel()&#13;&#10;) {&#13;&#10;    val uiState by viewModel.uiState.collectAsState()&#13;&#10;&#13;&#10;    LaunchedEffect(eventId) {&#13;&#10;        viewModel.loadEvent(eventId)&#13;&#10;    }&#13;&#10;&#13;&#10;    Scaffold(&#13;&#10;        topBar = {&#13;&#10;            TopAppBar(&#13;&#10;                title = {&#13;&#10;                    Text(&#13;&#10;                        text = uiState.event?.title ?: &quot;&quot;,&#13;&#10;                        maxLines = 1,&#13;&#10;                        overflow = TextOverflow.Ellipsis&#13;&#10;                    )&#13;&#10;                },&#13;&#10;                navigationIcon = {&#13;&#10;                    IconButton(onClick = { navController.popBackStack() }) {&#13;&#10;                        Icon(&#13;&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#13;&#10;                            contentDescription = &quot;Voltar&quot;,&#13;&#10;                            tint = MaterialTheme.colorScheme.primary&#13;&#10;                        )&#13;&#10;                    }&#13;&#10;                },&#13;&#10;                colors = TopAppBarDefaults.topAppBarColors(&#13;&#10;                    containerColor = Color.White&#13;&#10;                )&#13;&#10;            )&#13;&#10;        }&#13;&#10;    ) { paddingValues -&gt;&#13;&#10;        Box(&#13;&#10;            modifier = Modifier&#13;&#10;                .fillMaxSize()&#13;&#10;                .padding(paddingValues)&#13;&#10;                .background(Color.White)&#13;&#10;        ) {&#13;&#10;            when {&#13;&#10;                uiState.isLoading -&gt; {&#13;&#10;                    CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))&#13;&#10;                }&#13;&#10;                uiState.error != null -&gt; {&#13;&#10;                    Text(&#13;&#10;                        text = uiState.error!!,&#13;&#10;                        modifier = Modifier.align(Alignment.Center),&#13;&#10;                        color = Color.Red&#13;&#10;                    )&#13;&#10;                }&#13;&#10;                uiState.event != null -&gt; {&#13;&#10;                    EventDetailsContent(&#13;&#10;                        event = uiState.event!!,&#13;&#10;                        isConfirmed = uiState.isCurrentUserConfirmed,&#13;&#10;                        isInterested = uiState.isCurrentUserInterested,&#13;&#10;                        onConfirmClick = { viewModel.togglePresenceConfirmation() },&#13;&#10;                        onInterestClick = { viewModel.toggleInterest() },&#13;&#10;                        navController = navController&#13;&#10;                    )&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;@Composable&#13;&#10;private fun EventDetailsContent(&#13;&#10;    event: Event,&#13;&#10;    isConfirmed: Boolean,&#13;&#10;    isInterested: Boolean,&#13;&#10;    onConfirmClick: () -&gt; Unit,&#13;&#10;    onInterestClick: () -&gt; Unit,&#13;&#10;    navController: NavHostController&#13;&#10;) {&#13;&#10;    LazyColumn(&#13;&#10;        modifier = Modifier.fillMaxSize()&#13;&#10;    ) {&#13;&#10;        item {&#13;&#10;            AsyncImage(&#13;&#10;                model = ImageRequest.Builder(LocalContext.current)&#13;&#10;                    .data(event.imageUrl)&#13;&#10;                    .crossfade(true)&#13;&#10;                    .build(),&#13;&#10;                placeholder = painterResource(R.drawable.placeholder_event),&#13;&#10;                contentDescription = event.title,&#13;&#10;                modifier = Modifier&#13;&#10;                    .fillMaxWidth()&#13;&#10;                    .height(250.dp),&#13;&#10;                contentScale = ContentScale.Crop&#13;&#10;            )&#13;&#10;        }&#13;&#10;&#13;&#10;        item {&#13;&#10;            Column(&#13;&#10;                modifier = Modifier&#13;&#10;                    .fillMaxWidth()&#13;&#10;                    .padding(16.dp)&#13;&#10;            ) {&#13;&#10;                Text(&#13;&#10;                    text = event.title,&#13;&#10;                    style = MaterialTheme.typography.headlineLarge,&#13;&#10;                    color = Primary,&#13;&#10;                )&#13;&#10;&#13;&#10;                Spacer(modifier = Modifier.height(8.dp))&#13;&#10;&#13;&#10;                Row(&#13;&#10;                    modifier = Modifier.fillMaxWidth(),&#13;&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#13;&#10;                    verticalAlignment = Alignment.CenterVertically&#13;&#10;                ) {&#13;&#10;                    Row(horizontalArrangement = Arrangement.spacedBy(16.dp)) {&#13;&#10;                        Text(&#13;&#10;                            text = &quot;${event.confirmedCount} Confirmados&quot;,&#13;&#10;                            style = MaterialTheme.typography.bodySmall,&#13;&#10;                            color = Secondary,&#13;&#10;                            modifier = Modifier.clickable {&#13;&#10;                                navController.navigate(&quot;userList/confirmados/${event.id}&quot;)&#13;&#10;                            }&#13;&#10;                        )&#13;&#10;                        Text(&#13;&#10;                            text = &quot;${event.interestedCount} Interessados&quot;,&#13;&#10;                            style = MaterialTheme.typography.bodySmall,&#13;&#10;                            color = Color.Gray&#13;&#10;                        )&#13;&#10;                    }&#13;&#10;&#13;&#10;                    // ------------------ Ícones provisórios ------------------&#13;&#10;                    Row {&#13;&#10;                        IconButton(onClick = onInterestClick) {&#13;&#10;                            Icon(&#13;&#10;                                imageVector = if (isInterested) Icons.Default.Favorite else Icons.Default.FavoriteBorder,&#13;&#10;                                contentDescription = if (isInterested) &quot;Tenho Interesse&quot; else &quot;Remover dos Interesses&quot;,&#13;&#10;                                tint = if (isInterested) Primary else Color.Gray,&#13;&#10;                                modifier = Modifier.size(28.dp)&#13;&#10;                            )&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                }&#13;&#10;&#13;&#10;                Button(&#13;&#10;                    onClick = onConfirmClick,&#13;&#10;                    colors = ButtonDefaults.buttonColors(&#13;&#10;                        containerColor = if (isConfirmed) Primary else Color.LightGray,&#13;&#10;                        contentColor = Color.White&#13;&#10;                    ),&#13;&#10;                    shape = RoundedCornerShape(50),&#13;&#10;                    contentPadding = PaddingValues(horizontal = 20.dp, vertical = 8.dp)&#13;&#10;                ) {&#13;&#10;                    Text(&quot;Eu vou&quot;)&#13;&#10;                }&#13;&#10;&#13;&#10;                Spacer(modifier = Modifier.height(16.dp))&#13;&#10;                Text(&#13;&#10;                    text = event.description,&#13;&#10;                    style = MaterialTheme.typography.bodyLarge,&#13;&#10;                    lineHeight = 22.sp&#13;&#10;                )&#13;&#10;&#13;&#10;                Spacer(modifier = Modifier.height(24.dp))&#13;&#10;                EventInfoSection(event = event)&#13;&#10;                Spacer(modifier = Modifier.height(16.dp))&#13;&#10;                Text(&#13;&#10;                    text = &quot;Criado por @${event.creatorUsername}&quot;,&#13;&#10;                    style = MaterialTheme.typography.bodySmall,&#13;&#10;                    color = Primary,&#13;&#10;                    modifier = Modifier.clickable {&#13;&#10;                        navController.navigate(&quot;profile/${event.creatorUsername}&quot;)&#13;&#10;                    }&#13;&#10;                )&#13;&#10;                Spacer(modifier = Modifier.height(24.dp))&#13;&#10;                EventLocationMap(event)&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;@Composable&#13;&#10;private fun EventLocationMap(event: Event) {&#13;&#10;    val lat = event.latitude&#13;&#10;    val lng = event.longitude&#13;&#10;    val context = LocalContext.current&#13;&#10;&#13;&#10;    // Logs de diagnóstico da chave&#13;&#10;    LaunchedEffect(Unit) {&#13;&#10;        val buildConfigKey = BuildConfig.PLACES_API_KEY&#13;&#10;        val appInfo = try {&#13;&#10;            context.packageManager.getApplicationInfo(context.packageName, PackageManager.GET_META_DATA)&#13;&#10;        } catch (e: Exception) { null }&#13;&#10;        val manifestKey = appInfo?.metaData?.getString(&quot;com.google.android.geo.API_KEY&quot;)&#13;&#10;        Log.d(&quot;MAPS_KEY_DEBUG&quot;, &quot;BuildConfig.PLACES_API_KEY='${'$'}buildConfigKey'&quot;)&#13;&#10;        Log.d(&quot;MAPS_KEY_DEBUG&quot;, &quot;Manifest meta-data com.google.android.geo.API_KEY='${'$'}manifestKey'&quot;)&#13;&#10;    }&#13;&#10;&#13;&#10;    Column(&#13;&#10;        modifier = Modifier&#13;&#10;            .fillMaxWidth()&#13;&#10;            .heightIn(min = 180.dp)&#13;&#10;    ) {&#13;&#10;        Text(&#13;&#10;            text = &quot;Localização&quot;,&#13;&#10;            style = MaterialTheme.typography.titleMedium,&#13;&#10;            color = Primary&#13;&#10;        )&#13;&#10;        Spacer(modifier = Modifier.height(8.dp))&#13;&#10;        if (lat != null &amp;&amp; lng != null) {&#13;&#10;            val mapView = remember { MapView(context) }&#13;&#10;            // Lifecycle handling&#13;&#10;            DisposableEffect(mapView) {&#13;&#10;                mapView.onCreate(null)&#13;&#10;                mapView.onResume()&#13;&#10;                onDispose {&#13;&#10;                    mapView.onPause()&#13;&#10;                    mapView.onDestroy()&#13;&#10;                }&#13;&#10;            }&#13;&#10;            val target = remember(lat, lng) { LatLng(lat, lng) }&#13;&#10;            // Configure map once&#13;&#10;            LaunchedEffect(mapView, target) {&#13;&#10;                mapView.getMapAsync { googleMap: GoogleMap -&gt;&#13;&#10;                    googleMap.uiSettings.isMapToolbarEnabled = false&#13;&#10;                    googleMap.moveCamera(CameraUpdateFactory.newLatLngZoom(target, 15f))&#13;&#10;                    googleMap.clear()&#13;&#10;                    googleMap.addMarker(&#13;&#10;                        MarkerOptions()&#13;&#10;                            .position(target)&#13;&#10;                            .title(event.title)&#13;&#10;                            .snippet(event.location)&#13;&#10;                    )&#13;&#10;                }&#13;&#10;            }&#13;&#10;            fun openExternalMap() {&#13;&#10;                val gmmIntentUri = Uri.parse(&quot;geo:$lat,$lng?q=$lat,$lng(${Uri.encode(event.title.ifBlank { &quot;Evento&quot; })})&quot;)&#13;&#10;                val mapIntent = Intent(Intent.ACTION_VIEW, gmmIntentUri).apply { setPackage(&quot;com.google.android.apps.maps&quot;) }&#13;&#10;                if (mapIntent.resolveActivity(context.packageManager) == null) {&#13;&#10;                    context.startActivity(&#13;&#10;                        Intent(Intent.ACTION_VIEW, Uri.parse(&quot;https://www.google.com/maps/search/?api=1&amp;query=$lat,$lng&quot;))&#13;&#10;                    )&#13;&#10;                } else context.startActivity(mapIntent)&#13;&#10;            }&#13;&#10;            Box(&#13;&#10;                modifier = Modifier&#13;&#10;                    .fillMaxWidth()&#13;&#10;                    .height(200.dp)&#13;&#10;                    .clip(RoundedCornerShape(12.dp))&#13;&#10;                    .clickable { openExternalMap() }&#13;&#10;            ) {&#13;&#10;                AndroidView(factory = { mapView }) { mView -&gt;&#13;&#10;                    // Add listeners after map ready&#13;&#10;                    mView.getMapAsync { googleMap -&gt;&#13;&#10;                        googleMap.setOnMapClickListener { openExternalMap() }&#13;&#10;                        googleMap.setOnMarkerClickListener {&#13;&#10;                            openExternalMap(); true&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }&#13;&#10;            Spacer(modifier = Modifier.height(4.dp))&#13;&#10;            Text(&#13;&#10;                text = &quot;Toque para abrir no Google Maps&quot;,&#13;&#10;                style = MaterialTheme.typography.bodySmall,&#13;&#10;                color = Secondary&#13;&#10;            )&#13;&#10;        } else {&#13;&#10;            Text(&#13;&#10;                text = &quot;Localização não disponível&quot;,&#13;&#10;                style = MaterialTheme.typography.bodyMedium,&#13;&#10;                color = Color.Gray&#13;&#10;            )&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;@Composable&#13;&#10;fun EventInfoSection(event: Event) {&#13;&#10;    val dateFormatter = remember { SimpleDateFormat(&quot;dd 'de' MMMM&quot;, Locale(&quot;pt&quot;, &quot;BR&quot;)) }&#13;&#10;&#13;&#10;    Column(&#13;&#10;        verticalArrangement = Arrangement.spacedBy(12.dp)&#13;&#10;    ) {&#13;&#10;        EventInfoItem(&#13;&#10;            icon = Icons.Default.LocationOn,&#13;&#10;            text = event.location&#13;&#10;        )&#13;&#10;&#13;&#10;        event.eventDate?.let { date -&gt;&#13;&#10;            val formattedDate = dateFormatter.format(date).replaceFirstChar { it.uppercase() }&#13;&#10;            val timeText = if (event.startTime != null &amp;&amp; event.endTime != null) {&#13;&#10;                &quot;$formattedDate | ${event.startTime} - ${event.endTime}&quot;&#13;&#10;            } else {&#13;&#10;                formattedDate&#13;&#10;            }&#13;&#10;            EventInfoItem(&#13;&#10;                icon = Icons.Default.DateRange,&#13;&#10;                text = timeText&#13;&#10;            )&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;@Composable&#13;&#10;fun EventInfoItem(&#13;&#10;    icon: androidx.compose.ui.graphics.vector.ImageVector,&#13;&#10;    text: String&#13;&#10;) {&#13;&#10;    Row(&#13;&#10;        verticalAlignment = Alignment.CenterVertically,&#13;&#10;        horizontalArrangement = Arrangement.spacedBy(8.dp)&#13;&#10;    ) {&#13;&#10;        Icon(&#13;&#10;            icon,&#13;&#10;            contentDescription = null,&#13;&#10;            tint = Color(0xFF8B5A96),&#13;&#10;            modifier = Modifier.size(20.dp)&#13;&#10;        )&#13;&#10;        Text(&#13;&#10;            text = text,&#13;&#10;            style = MaterialTheme.typography.bodyMedium&#13;&#10;        )&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/event/EventDetailsViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/event/EventDetailsViewModel.kt" />
              <option name="originalContent" value="package com.pdm.zone.ui.screens.event&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FieldValue&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.pdm.zone.data.model.Event&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;&#10;data class EventDetailsUiState(&#10;    val isLoading: Boolean = true,&#10;    val event: Event? = null,&#10;    val isCurrentUserConfirmed: Boolean = false,&#10;    val isCurrentUserInterested: Boolean = false,&#10;    val error: String? = null&#10;)&#10;&#10;class EventDetailsViewModel : ViewModel() {&#10;&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _uiState = MutableStateFlow(EventDetailsUiState())&#10;    val uiState: StateFlow&lt;EventDetailsUiState&gt; = _uiState.asStateFlow()&#10;&#10;    fun loadEvent(eventId: String) {&#10;        if (eventId.isBlank()) {&#10;            _uiState.update { it.copy(isLoading = false, error = &quot;ID do evento inválido.&quot;) }&#10;            return&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            _uiState.update { it.copy(isLoading = true) }&#10;            try {&#10;                val documentSnapshot = db.collection(&quot;events&quot;).document(eventId).get().await()&#10;&#10;                if (documentSnapshot.exists()) {&#10;                    val event = documentSnapshot.toObject(Event::class.java)&#10;                    if (event != null) {&#10;                        val currentUserId = auth.currentUser?.uid&#10;                        val isConfirmed = event.attendees.contains(currentUserId)&#10;                        val isInterested = event.interestedUsers.contains(currentUserId)&#10;&#10;                        _uiState.update {&#10;                            it.copy(&#10;                                isLoading = false,&#10;                                event = event,&#10;                                isCurrentUserConfirmed = isConfirmed,&#10;                                isCurrentUserInterested = isInterested,&#10;                                error = null&#10;                            )&#10;                        }&#10;                    } else {&#10;                        _uiState.update { it.copy(isLoading = false, error = &quot;Falha ao ler dados do evento.&quot;) }&#10;                    }&#10;                } else {&#10;                    _uiState.update { it.copy(isLoading = false, error = &quot;Evento não encontrado.&quot;) }&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.update {&#10;                    it.copy(isLoading = false, error = &quot;Falha ao carregar o evento: ${e.message}&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun togglePresenceConfirmation() {&#10;        viewModelScope.launch {&#10;            val currentState = _uiState.value&#10;            val event = currentState.event ?: return@launch&#10;            val currentUserId = auth.currentUser?.uid ?: return@launch&#10;&#10;            val isCurrentlyConfirmed = currentState.isCurrentUserConfirmed&#10;&#10;            val newAttendeesList = if (isCurrentlyConfirmed) {&#10;                event.attendees - currentUserId&#10;            } else {&#10;                event.attendees + currentUserId&#10;            }&#10;            _uiState.update {&#10;                it.copy(&#10;                    isCurrentUserConfirmed = !isCurrentlyConfirmed,&#10;                    event = event.copy(attendees = newAttendeesList)&#10;                )&#10;            }&#10;&#10;            try {&#10;                val eventRef = db.collection(&quot;events&quot;).document(event.id)&#10;                val fieldUpdate = if (isCurrentlyConfirmed) {&#10;                    FieldValue.arrayRemove(currentUserId)&#10;                } else {&#10;                    FieldValue.arrayUnion(currentUserId)&#10;                }&#10;                eventRef.update(&quot;attendees&quot;, fieldUpdate).await()&#10;            } catch (e: Exception) {&#10;                _uiState.update {&#10;                    currentState.copy(error = &quot;Ocorreu uma falha. Tente novamente.&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun toggleInterest() {&#10;        viewModelScope.launch {&#10;            val currentState = _uiState.value&#10;            val event = currentState.event ?: return@launch&#10;            val currentUserId = auth.currentUser?.uid ?: return@launch&#10;            val isCurrentlyInterested = currentState.isCurrentUserInterested&#10;            val newInterestedList = if (isCurrentlyInterested) event.interestedUsers - currentUserId else event.interestedUsers + currentUserId&#10;            _uiState.update { it.copy(isCurrentUserInterested = !isCurrentlyInterested, event = event.copy(interestedUsers = newInterestedList)) }&#10;            try {&#10;                val eventRef = db.collection(&quot;events&quot;).document(event.id)&#10;                val fieldUpdate = if (isCurrentlyInterested) FieldValue.arrayRemove(currentUserId) else FieldValue.arrayUnion(currentUserId)&#10;                eventRef.update(&quot;interestedUsers&quot;, fieldUpdate).await()&#10;            } catch (e: Exception) {&#10;                _uiState.update { currentState.copy(error = &quot;Ocorreu uma falha. Tente novamente.&quot;) }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.pdm.zone.ui.screens.event&#13;&#10;&#13;&#10;import androidx.lifecycle.ViewModel&#13;&#10;import androidx.lifecycle.viewModelScope&#13;&#10;import com.google.firebase.auth.FirebaseAuth&#13;&#10;import com.google.firebase.firestore.FieldValue&#13;&#10;import com.google.firebase.firestore.FirebaseFirestore&#13;&#10;import com.pdm.zone.data.model.Event&#13;&#10;import kotlinx.coroutines.flow.MutableStateFlow&#13;&#10;import kotlinx.coroutines.flow.StateFlow&#13;&#10;import kotlinx.coroutines.flow.asStateFlow&#13;&#10;import kotlinx.coroutines.flow.update&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;import kotlinx.coroutines.tasks.await&#13;&#10;&#13;&#10;data class EventDetailsUiState(&#13;&#10;    val isLoading: Boolean = true,&#13;&#10;    val event: Event? = null,&#13;&#10;    val isCurrentUserConfirmed: Boolean = false,&#13;&#10;    val isCurrentUserInterested: Boolean = false,&#13;&#10;    val error: String? = null&#13;&#10;)&#13;&#10;&#13;&#10;class EventDetailsViewModel : ViewModel() {&#13;&#10;&#13;&#10;    private val db = FirebaseFirestore.getInstance()&#13;&#10;    private val auth = FirebaseAuth.getInstance()&#13;&#10;&#13;&#10;    private val _uiState = MutableStateFlow(EventDetailsUiState())&#13;&#10;    val uiState: StateFlow&lt;EventDetailsUiState&gt; = _uiState.asStateFlow()&#13;&#10;&#13;&#10;    fun loadEvent(eventId: String) {&#13;&#10;        if (eventId.isBlank()) {&#13;&#10;            _uiState.update { it.copy(isLoading = false, error = &quot;ID do evento inválido.&quot;) }&#13;&#10;            return&#13;&#10;        }&#13;&#10;&#13;&#10;        viewModelScope.launch {&#13;&#10;            _uiState.update { it.copy(isLoading = true) }&#13;&#10;            try {&#13;&#10;                val documentSnapshot = db.collection(&quot;events&quot;).document(eventId).get().await()&#13;&#10;&#13;&#10;                if (documentSnapshot.exists()) {&#13;&#10;                    val event = documentSnapshot.toObject(Event::class.java)&#13;&#10;                    if (event != null) {&#13;&#10;                        val currentUserId = auth.currentUser?.uid&#13;&#10;                        val isConfirmed = event.attendees.contains(currentUserId)&#13;&#10;                        val isInterested = event.interestedUsers.contains(currentUserId)&#13;&#10;&#13;&#10;                        _uiState.update {&#13;&#10;                            it.copy(&#13;&#10;                                isLoading = false,&#13;&#10;                                event = event,&#13;&#10;                                isCurrentUserConfirmed = isConfirmed,&#13;&#10;                                isCurrentUserInterested = isInterested,&#13;&#10;                                error = null&#13;&#10;                            )&#13;&#10;                        }&#13;&#10;                    } else {&#13;&#10;                        _uiState.update { it.copy(isLoading = false, error = &quot;Falha ao ler dados do evento.&quot;) }&#13;&#10;                    }&#13;&#10;                } else {&#13;&#10;                    _uiState.update { it.copy(isLoading = false, error = &quot;Evento não encontrado.&quot;) }&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                _uiState.update {&#13;&#10;                    it.copy(isLoading = false, error = &quot;Falha ao carregar o evento: ${e.message}&quot;)&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun togglePresenceConfirmation() {&#13;&#10;        viewModelScope.launch {&#13;&#10;            val currentState = _uiState.value&#13;&#10;            val event = currentState.event ?: return@launch&#13;&#10;            val currentUserId = auth.currentUser?.uid ?: return@launch&#13;&#10;&#13;&#10;            val isCurrentlyConfirmed = currentState.isCurrentUserConfirmed&#13;&#10;&#13;&#10;            val newAttendeesList = if (isCurrentlyConfirmed) {&#13;&#10;                event.attendees - currentUserId&#13;&#10;            } else {&#13;&#10;                event.attendees + currentUserId&#13;&#10;            }&#13;&#10;            &#13;&#10;            // Atualizando o estado local imediatamente para feedback instantâneo&#13;&#10;            _uiState.update {&#13;&#10;                it.copy(&#13;&#10;                    isCurrentUserConfirmed = !isCurrentlyConfirmed,&#13;&#10;                    event = event.copy(attendees = newAttendeesList)&#13;&#10;                )&#13;&#10;            }&#13;&#10;&#13;&#10;            try {&#13;&#10;                val eventRef = db.collection(&quot;events&quot;).document(event.id)&#13;&#10;                val fieldUpdate = if (isCurrentlyConfirmed) {&#13;&#10;                    FieldValue.arrayRemove(currentUserId)&#13;&#10;                } else {&#13;&#10;                    FieldValue.arrayUnion(currentUserId)&#13;&#10;                }&#13;&#10;                &#13;&#10;                // Atualiza o evento no Firestore&#13;&#10;                eventRef.update(&quot;attendees&quot;, fieldUpdate).await()&#13;&#10;                &#13;&#10;                // Se o usuário desconfirmar presença e estava interessado, mantém na lista de interessados&#13;&#10;                if (isCurrentlyConfirmed &amp;&amp; !currentState.isCurrentUserInterested) {&#13;&#10;                    eventRef.update(&quot;interestedUsers&quot;, FieldValue.arrayUnion(currentUserId)).await()&#13;&#10;                    _uiState.update {&#13;&#10;                        it.copy(&#13;&#10;                            isCurrentUserInterested = true,&#13;&#10;                            event = it.event?.copy(&#13;&#10;                                interestedUsers = it.event.interestedUsers + currentUserId&#13;&#10;                            )&#13;&#10;                        )&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                // Em caso de erro, revertemos para o estado anterior&#13;&#10;                _uiState.update {&#13;&#10;                    currentState.copy(error = &quot;Ocorreu uma falha. Tente novamente.&quot;)&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun toggleInterest() {&#13;&#10;        viewModelScope.launch {&#13;&#10;            val currentState = _uiState.value&#13;&#10;            val event = currentState.event ?: return@launch&#13;&#10;            val currentUserId = auth.currentUser?.uid ?: return@launch&#13;&#10;            val isCurrentlyInterested = currentState.isCurrentUserInterested&#13;&#10;            val newInterestedList = if (isCurrentlyInterested) event.interestedUsers - currentUserId else event.interestedUsers + currentUserId&#13;&#10;            _uiState.update { it.copy(isCurrentUserInterested = !isCurrentlyInterested, event = event.copy(interestedUsers = newInterestedList)) }&#13;&#10;            try {&#13;&#10;                val eventRef = db.collection(&quot;events&quot;).document(event.id)&#13;&#10;                val fieldUpdate = if (isCurrentlyInterested) FieldValue.arrayRemove(currentUserId) else FieldValue.arrayUnion(currentUserId)&#13;&#10;                eventRef.update(&quot;interestedUsers&quot;, fieldUpdate).await()&#13;&#10;            } catch (e: Exception) {&#13;&#10;                _uiState.update { currentState.copy(error = &quot;Ocorreu uma falha. Tente novamente.&quot;) }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/event/EventListPage.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/event/EventListPage.kt" />
              <option name="originalContent" value="package com.pdm.zone.ui.screens.event&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.LocationOn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavHostController&#10;import coil.compose.AsyncImage&#10;import coil.request.ImageRequest&#10;import com.pdm.zone.R&#10;import com.pdm.zone.data.model.Event&#10;import com.pdm.zone.ui.theme.Primary&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;@Composable&#10;fun ListPage(&#10;    navController: NavHostController,&#10;    viewModel: ListViewModel = viewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsState()&#10;    val dateFormatter = remember { SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale(&quot;pt&quot;, &quot;BR&quot;)) }&#10;    val timeFormatter = remember { SimpleDateFormat(&quot;HH:mm&quot;, Locale(&quot;pt&quot;, &quot;BR&quot;)) }&#10;&#10;    Scaffold { innerPadding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(innerPadding)&#10;        ) {&#10;            // Título da página&#10;            Text(&#10;                text = &quot;Meus Eventos&quot;,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = 24.sp,&#10;                color = Primary,&#10;                modifier = Modifier.padding(horizontal = 16.dp, vertical = 16.dp)&#10;            )&#10;&#10;            // Conteúdo dos eventos&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(8.dp)&#10;            ) {&#10;                when {&#10;                    uiState.isLoading -&gt; {&#10;                        CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))&#10;                    }&#10;                    uiState.error != null -&gt; {&#10;                        Text(&#10;                            text = uiState.error!!,&#10;                            modifier = Modifier.align(Alignment.Center),&#10;                            color = Color.Red&#10;                        )&#10;                    }&#10;                    else -&gt; {&#10;                        if (uiState.confirmedEvents.isEmpty()) {&#10;                            Box(&#10;                                modifier = Modifier.fillMaxSize(),&#10;                                contentAlignment = Alignment.Center&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;Você não confirmou presença em nenhum evento próximo&quot;,&#10;                                    color = Color.Gray,&#10;                                    modifier = Modifier.padding(16.dp)&#10;                                )&#10;                            }&#10;                        } else {&#10;                            LazyColumn(&#10;                                modifier = Modifier.fillMaxSize(),&#10;                                contentPadding = PaddingValues(vertical = 8.dp)&#10;                            ) {&#10;                                items(uiState.confirmedEvents) { event -&gt;&#10;                                    Card(&#10;                                        modifier = Modifier&#10;                                            .fillMaxWidth()&#10;                                            .padding(vertical = 8.dp, horizontal = 16.dp)&#10;                                            .clickable {&#10;                                                navController.navigate(&quot;eventDetails/${event.id}&quot;)&#10;                                            }&#10;                                    ) {&#10;                                        Row(&#10;                                            modifier = Modifier&#10;                                                .fillMaxWidth()&#10;                                                .padding(8.dp),&#10;                                            verticalAlignment = Alignment.CenterVertically&#10;                                        ) {&#10;                                            // Imagem do evento&#10;                                            AsyncImage(&#10;                                                model = ImageRequest.Builder(LocalContext.current)&#10;                                                    .data(event.imageUrl)&#10;                                                    .crossfade(true)&#10;                                                    .build(),&#10;                                                placeholder = painterResource(R.drawable.placeholder_event),&#10;                                                contentDescription = event.title,&#10;                                                contentScale = ContentScale.Crop,&#10;                                                modifier = Modifier&#10;                                                    .size(100.dp)&#10;                                                    .padding(end = 8.dp)&#10;                                            )&#10;&#10;                                            // Detalhes do evento&#10;                                            Column(&#10;                                                modifier = Modifier&#10;                                                    .weight(1f)&#10;                                                    .padding(start = 8.dp)&#10;                                            ) {&#10;                                                // Título&#10;                                                Text(&#10;                                                    text = event.title,&#10;                                                    style = MaterialTheme.typography.titleMedium,&#10;                                                    color = Primary,&#10;                                                    fontWeight = FontWeight.Bold&#10;                                                )&#10;&#10;                                                // Local&#10;                                                Row(&#10;                                                    verticalAlignment = Alignment.CenterVertically,&#10;                                                    modifier = Modifier.padding(top = 4.dp)&#10;                                                ) {&#10;                                                    Icon(&#10;                                                        Icons.Default.LocationOn,&#10;                                                        contentDescription = &quot;Local&quot;,&#10;                                                        tint = Color.Gray,&#10;                                                        modifier = Modifier.size(16.dp)&#10;                                                    )&#10;                                                    Spacer(modifier = Modifier.width(4.dp))&#10;                                                    Text(&#10;                                                        text = event.location,&#10;                                                        style = MaterialTheme.typography.bodySmall,&#10;                                                        color = Color.Gray&#10;                                                    )&#10;                                                }&#10;&#10;                                                // Data&#10;                                                event.eventDate?.let { date -&gt;&#10;                                                    Row(&#10;                                                        verticalAlignment = Alignment.CenterVertically,&#10;                                                        modifier = Modifier.padding(top = 4.dp)&#10;                                                    ) {&#10;                                                        Text(&#10;                                                            text = &quot;Data:&quot;,&#10;                                                            style = MaterialTheme.typography.bodySmall,&#10;                                                            fontWeight = FontWeight.Bold,&#10;                                                            color = Color.Gray&#10;                                                        )&#10;                                                        Spacer(modifier = Modifier.width(4.dp))&#10;                                                        Text(&#10;                                                            text = dateFormatter.format(date),&#10;                                                            style = MaterialTheme.typography.bodySmall,&#10;                                                            color = Color.Gray&#10;                                                        )&#10;                                                    }&#10;                                                }&#10;&#10;                                                // Horário&#10;                                                Row(&#10;                                                    verticalAlignment = Alignment.CenterVertically,&#10;                                                    modifier = Modifier.padding(top = 4.dp)&#10;                                                ) {&#10;                                                    Text(&#10;                                                        text = &quot;Horário:&quot;,&#10;                                                        style = MaterialTheme.typography.bodySmall,&#10;                                                        fontWeight = FontWeight.Bold,&#10;                                                        color = Color.Gray&#10;                                                    )&#10;                                                    Spacer(modifier = Modifier.width(4.dp))&#10;                                                    Text(&#10;                                                        text = &quot;${event.startTime ?: &quot;--:--&quot;} - ${event.endTime ?: &quot;--:--&quot;}&quot;,&#10;                                                        style = MaterialTheme.typography.bodySmall,&#10;                                                        color = Color.Gray&#10;                                                    )&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.pdm.zone.ui.screens.event&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.LocationOn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavHostController&#10;import coil.compose.AsyncImage&#10;import coil.request.ImageRequest&#10;import com.pdm.zone.R&#10;import com.pdm.zone.data.model.Event&#10;import com.pdm.zone.ui.components.CompactEventCard&#10;import com.pdm.zone.ui.theme.Primary&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;@Composable&#10;fun ListPage(&#10;    navController: NavHostController,&#10;    viewModel: ListViewModel = viewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsState()&#10;    val dateFormatter = remember { SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale(&quot;pt&quot;, &quot;BR&quot;)) }&#10;    val timeFormatter = remember { SimpleDateFormat(&quot;HH:mm&quot;, Locale(&quot;pt&quot;, &quot;BR&quot;)) }&#10;&#10;    Scaffold { innerPadding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(innerPadding)&#10;        ) {&#10;            // Título da página&#10;            Text(&#10;                text = &quot;Meus Eventos&quot;,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = 24.sp,&#10;                color = Primary,&#10;                modifier = Modifier.padding(horizontal = 16.dp, vertical = 16.dp)&#10;            )&#10;&#10;            // Conteúdo dos eventos&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(8.dp)&#10;            ) {&#10;                when {&#10;                    uiState.isLoading -&gt; {&#10;                        CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))&#10;                    }&#10;                    uiState.error != null -&gt; {&#10;                        Text(&#10;                            text = uiState.error!!,&#10;                            modifier = Modifier.align(Alignment.Center),&#10;                            color = Color.Red&#10;                        )&#10;                    }&#10;                    else -&gt; {&#10;                        if (uiState.confirmedEvents.isEmpty()) {&#10;                            Box(&#10;                                modifier = Modifier.fillMaxSize(),&#10;                                contentAlignment = Alignment.Center&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;Você não confirmou presença em nenhum evento próximo&quot;,&#10;                                    color = Color.Gray,&#10;                                    modifier = Modifier.padding(16.dp)&#10;                                )&#10;                            }&#10;                        } else {&#10;                            LazyColumn(&#10;                                modifier = Modifier.fillMaxSize(),&#10;                                contentPadding = PaddingValues(vertical = 8.dp)&#10;                            ) {&#10;                                items(uiState.confirmedEvents) { event -&gt;&#10;                                    CompactEventCard(&#10;                                        event = event,&#10;                                        onCardClick = {&#10;                                            navController.navigate(&quot;eventDetails/${it.id}&quot;)&#10;                                        }&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/event/EventListViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/event/EventListViewModel.kt" />
              <option name="originalContent" value="package com.pdm.zone.ui.screens.event&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.Query&#10;import com.pdm.zone.data.model.Event&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;import java.util.Date&#10;&#10;// Estado da UI específico para a tela de lista de eventos&#10;data class ListUiState(&#10;    val isLoading: Boolean = true,&#10;    val confirmedUpcomingEvents: List&lt;Event&gt; = emptyList(),&#10;    val confirmedPastEvents: List&lt;Event&gt; = emptyList(),&#10;    val error: String? = null&#10;)&#10;&#10;class ListViewModel : ViewModel() {&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _uiState = MutableStateFlow(ListUiState())&#10;    val uiState = _uiState.asStateFlow()&#10;&#10;    init {&#10;        loadUserConfirmedEvents()&#10;    }&#10;&#10;    fun loadUserConfirmedEvents() {&#10;        viewModelScope.launch {&#10;            _uiState.update { it.copy(isLoading = true) }&#10;            try {&#10;                val currentUserId = auth.currentUser?.uid&#10;                if (currentUserId == null) {&#10;                    _uiState.update { it.copy(isLoading = false, error = &quot;Usuário não autenticado&quot;) }&#10;                    return@launch&#10;                }&#10;&#10;                // Busca eventos que o usuário confirmou presença&#10;                val eventsSnapshot = db.collection(&quot;events&quot;)&#10;                    .whereArrayContains(&quot;attendees&quot;, currentUserId)&#10;                    .orderBy(&quot;eventDate&quot;, Query.Direction.ASCENDING)&#10;                    .get()&#10;                    .await()&#10;&#10;                val allConfirmedEvents = eventsSnapshot.toObjects(Event::class.java)&#10;&#10;                // Separar eventos por data (passados e futuros)&#10;                val currentDate = Date()&#10;                val (upcoming, past) = allConfirmedEvents.partition { event -&gt;&#10;                    event.eventDate?.after(currentDate) ?: false&#10;                }&#10;&#10;                _uiState.update {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        confirmedUpcomingEvents = upcoming,&#10;                        confirmedPastEvents = past,&#10;                        error = null&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.update {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        error = &quot;Falha ao carregar eventos: ${e.message}&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.pdm.zone.ui.screens.event&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.pdm.zone.data.model.Event&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;import java.util.Date&#10;&#10;// Estado da UI específico para a tela de lista de eventos&#10;data class ListUiState(&#10;    val isLoading: Boolean = true,&#10;    val confirmedEvents: List&lt;Event&gt; = emptyList(),&#10;    val error: String? = null&#10;)&#10;&#10;class ListViewModel : ViewModel() {&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _uiState = MutableStateFlow(ListUiState())&#10;    val uiState = _uiState.asStateFlow()&#10;&#10;    init {&#10;        loadUserConfirmedEvents()&#10;    }&#10;&#10;    fun loadUserConfirmedEvents() {&#10;        viewModelScope.launch {&#10;            _uiState.update { it.copy(isLoading = true) }&#10;            try {&#10;                val currentUserId = auth.currentUser?.uid&#10;                if (currentUserId == null) {&#10;                    _uiState.update { it.copy(isLoading = false, error = &quot;Usuário não autenticado&quot;) }&#10;                    return@launch&#10;                }&#10;&#10;                // Busca eventos que o usuário confirmou presença&#10;                // Note que removemos o orderBy para evitar o erro de índice&#10;                val eventsSnapshot = db.collection(&quot;events&quot;)&#10;                    .whereArrayContains(&quot;attendees&quot;, currentUserId)&#10;                    .get()&#10;                    .await()&#10;&#10;                val allConfirmedEvents = eventsSnapshot.toObjects(Event::class.java)&#10;&#10;                // Separar apenas eventos futuros e ordenar por data&#10;                val currentDate = Date()&#10;                val upcomingEvents = allConfirmedEvents&#10;                    .filter { event -&gt; event.eventDate?.after(currentDate) ?: false }&#10;                    .sortedBy { it.eventDate }&#10;&#10;                _uiState.update {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        confirmedEvents = upcomingEvents,&#10;                        error = null&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.update {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        error = &quot;Falha ao carregar eventos: ${e.message}&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/event/EventRegisterPage.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/event/EventRegisterPage.kt" />
              <option name="originalContent" value="@file:OptIn(ExperimentalMaterial3Api::class)&#10;&#10;package com.pdm.zone.ui.screens.event&#10;&#10;import android.app.DatePickerDialog&#10;import android.app.TimePickerDialog&#10;import android.net.Uri&#10;import android.widget.Toast&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.KeyboardArrowDown&#10;import androidx.compose.material.icons.filled.KeyboardArrowUp&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavHostController&#10;import coil.compose.AsyncImage&#10;import com.google.android.libraries.places.api.Places&#10;import com.google.android.libraries.places.api.model.AutocompletePrediction&#10;import com.google.android.libraries.places.api.model.Place&#10;import com.google.android.libraries.places.api.net.PlacesClient&#10;import com.google.android.libraries.places.api.net.FindAutocompletePredictionsRequest&#10;import com.google.android.libraries.places.api.net.FetchPlaceRequest&#10;import com.pdm.zone.BuildConfig&#10;import com.pdm.zone.data.model.EventCategory&#10;import com.pdm.zone.ui.components.DataField&#10;import com.pdm.zone.ui.nav.BackHeader&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;@Composable&#10;fun EventRegisterPage(&#10;    navController: NavHostController,&#10;    viewModel: EventRegisterViewModel = viewModel(),&#10;    onSubmit: () -&gt; Unit = { navController.popBackStack() },&#10;) {&#10;    val context = LocalContext.current&#10;    val uiState by viewModel.uiState.collectAsState()&#10;&#10;    var title by remember { mutableStateOf(&quot;&quot;) }&#10;    var location by remember { mutableStateOf(&quot;&quot;) }&#10;    var description by remember { mutableStateOf(&quot;&quot;) }&#10;    var imageUri by remember { mutableStateOf&lt;Uri?&gt;(null) }&#10;    var selectedCategory by remember { mutableStateOf&lt;EventCategory?&gt;(null) }&#10;&#10;    var placeId by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var latitude by remember { mutableStateOf&lt;Double?&gt;(null) }&#10;    var longitude by remember { mutableStateOf&lt;Double?&gt;(null) }&#10;    var fullAddress by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var predictions by remember { mutableStateOf&lt;List&lt;AutocompletePrediction&gt;&gt;(emptyList()) }&#10;    var showPredictions by remember { mutableStateOf(false) }&#10;&#10;    val selectedCalendar = remember { Calendar.getInstance() }&#10;    var dateText by remember { mutableStateOf(&quot;&quot;) }&#10;    var startTimeText by remember { mutableStateOf(&quot;&quot;) }&#10;    var endTimeText by remember { mutableStateOf(&quot;&quot;) }&#10;&#10;    val dateFormatter = remember { SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale.getDefault()) }&#10;    val timeFormatter = remember { SimpleDateFormat(&quot;HH:mm&quot;, Locale.getDefault()) }&#10;&#10;    val datePickerDialog = remember {&#10;        DatePickerDialog(&#10;            context,&#10;            { _, year: Int, month: Int, dayOfMonth: Int -&gt;&#10;                selectedCalendar.set(Calendar.YEAR, year)&#10;                selectedCalendar.set(Calendar.MONTH, month)&#10;                selectedCalendar.set(Calendar.DAY_OF_MONTH, dayOfMonth)&#10;                dateText = dateFormatter.format(selectedCalendar.time)&#10;            },&#10;            selectedCalendar.get(Calendar.YEAR),&#10;            selectedCalendar.get(Calendar.MONTH),&#10;            selectedCalendar.get(Calendar.DAY_OF_MONTH)&#10;        ).apply {&#10;            datePicker.minDate = System.currentTimeMillis()&#10;        }&#10;    }&#10;&#10;    val imagePickerLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.GetContent()&#10;    ) { uri: Uri? -&gt;&#10;        imageUri = uri&#10;    }&#10;&#10;    LaunchedEffect(uiState.isSuccess) {&#10;        if (uiState.isSuccess) {&#10;            Toast.makeText(context, &quot;Evento cadastrado com sucesso!&quot;, Toast.LENGTH_SHORT).show()&#10;            viewModel.resetState()&#10;            onSubmit()&#10;        }&#10;    }&#10;    LaunchedEffect(uiState.error) {&#10;        uiState.error?.let {&#10;            Toast.makeText(context, it, Toast.LENGTH_LONG).show()&#10;            viewModel.resetState()&#10;        }&#10;    }&#10;&#10;    // Places init&#10;    val placesClient: PlacesClient = remember {&#10;        if (!Places.isInitialized()) {&#10;            Places.initialize(context, BuildConfig.PLACES_API_KEY)&#10;        }&#10;        Places.createClient(context)&#10;    }&#10;&#10;    fun searchPlaces(query: String) {&#10;        if (query.isBlank()) {&#10;            predictions = emptyList(); return&#10;        }&#10;        val request = FindAutocompletePredictionsRequest.builder()&#10;            .setQuery(query)&#10;            .build()&#10;        placesClient.findAutocompletePredictions(request)&#10;            .addOnSuccessListener { response -&gt;&#10;                predictions = response.autocompletePredictions&#10;                showPredictions = true&#10;            }&#10;            .addOnFailureListener { predictions = emptyList() }&#10;    }&#10;&#10;    fun fetchPlaceDetails(id: String) {&#10;        val placeRequest = FetchPlaceRequest.newInstance(id, listOf(Place.Field.ID, Place.Field.NAME, Place.Field.LAT_LNG, Place.Field.ADDRESS))&#10;        placesClient.fetchPlace(placeRequest)&#10;            .addOnSuccessListener { result -&gt;&#10;                val place = result.place&#10;                placeId = place.id&#10;                latitude = place.latLng?.latitude&#10;                longitude = place.latLng?.longitude&#10;                fullAddress = place.address&#10;            }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(rememberScrollState())&#10;            .padding(24.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    )  {&#10;        BackHeader(navController)&#10;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(180.dp)&#10;                .background(MaterialTheme.colorScheme.surfaceVariant, MaterialTheme.shapes.medium)&#10;                .clip(MaterialTheme.shapes.medium)&#10;                .clickable { imagePickerLauncher.launch(&quot;image/*&quot;) },&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            if (imageUri != null) {&#10;                AsyncImage(&#10;                    model = imageUri,&#10;                    contentDescription = &quot;Imagem do evento&quot;,&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentScale = ContentScale.Crop&#10;                )&#10;            } else {&#10;                Text(&quot;Clique para adicionar imagem&quot;, color = MaterialTheme.colorScheme.onSurfaceVariant)&#10;            }&#10;        }&#10;&#10;        DataField(value = title, onValueChange = { title = it }, label = &quot;Título&quot;, enabled = !uiState.isLoading, modifier = Modifier.fillMaxWidth())&#10;&#10;        // Campo de Local com Autocomplete&#10;        Column(modifier = Modifier.fillMaxWidth()) {&#10;            OutlinedTextField(&#10;                value = location,&#10;                onValueChange = {&#10;                    location = it&#10;                    placeId = null&#10;                    latitude = null&#10;                    longitude = null&#10;                    fullAddress = null&#10;                    searchPlaces(it)&#10;                },&#10;                label = { Text(&quot;Local&quot;) },&#10;                enabled = !uiState.isLoading,&#10;                modifier = Modifier.fillMaxWidth()&#10;            )&#10;            DropdownMenu(&#10;                expanded = showPredictions &amp;&amp; predictions.isNotEmpty(),&#10;                onDismissRequest = { showPredictions = false },&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                predictions.forEach { prediction -&gt;&#10;                    DropdownMenuItem(&#10;                        text = { Text(prediction.getFullText(null).toString()) },&#10;                        onClick = {&#10;                            location = prediction.getPrimaryText(null).toString()&#10;                            fetchPlaceDetails(prediction.placeId)&#10;                            showPredictions = false&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;            if (fullAddress != null) {&#10;                Text(fullAddress!!, style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.primary)&#10;            }&#10;        }&#10;&#10;        DataField(value = description, onValueChange = { description = it }, label = &quot;Descrição&quot;, enabled = !uiState.isLoading, modifier = Modifier.fillMaxWidth())&#10;&#10;        CategoryDropdown(&#10;            selectedCategory = selectedCategory,&#10;            onCategorySelected = { selectedCategory = it },&#10;            enabled = !uiState.isLoading&#10;        )&#10;&#10;        ClickableOutlinedTextField(value = dateText, onClick = { datePickerDialog.show() }, label = &quot;Data&quot;, enabled = !uiState.isLoading, modifier = Modifier.fillMaxWidth())&#10;&#10;        val startTimePicker = rememberTimePicker(context) { hour, minute -&gt;&#10;            selectedCalendar.set(Calendar.HOUR_OF_DAY, hour)&#10;            selectedCalendar.set(Calendar.MINUTE, minute)&#10;            startTimeText = timeFormatter.format(selectedCalendar.time)&#10;        }&#10;        val endTimePicker = rememberTimePicker(context) { hour, minute -&gt;&#10;            val endCalendar = Calendar.getInstance().apply {&#10;                time = selectedCalendar.time&#10;                set(Calendar.HOUR_OF_DAY, hour)&#10;                set(Calendar.MINUTE, minute)&#10;            }&#10;            endTimeText = timeFormatter.format(endCalendar.time)&#10;        }&#10;&#10;        Row(horizontalArrangement = Arrangement.spacedBy(16.dp), modifier = Modifier.fillMaxWidth()) {&#10;            ClickableOutlinedTextField(value = startTimeText, onClick = { startTimePicker.show() }, label = &quot;Início&quot;, modifier = Modifier.weight(1f), enabled = !uiState.isLoading)&#10;            ClickableOutlinedTextField(value = endTimeText, onClick = { endTimePicker.show() }, label = &quot;Fim&quot;, modifier = Modifier.weight(1f), enabled = !uiState.isLoading)&#10;        }&#10;&#10;        Button(&#10;            onClick = {&#10;                viewModel.createEvent(&#10;                    context = context,&#10;                    title = title,&#10;                    description = description,&#10;                    location = location,&#10;                    category = selectedCategory!!,&#10;                    imageUri = imageUri,&#10;                    eventCalendar = selectedCalendar,&#10;                    startTime = startTimeText,&#10;                    endTime = endTimeText,&#10;                    placeId = placeId,&#10;                    latitude = latitude,&#10;                    longitude = longitude,&#10;                    address = fullAddress&#10;                )&#10;            },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            enabled = !uiState.isLoading &amp;&amp; selectedCategory != null,&#10;            shape = MaterialTheme.shapes.medium&#10;        ) {&#10;            if (uiState.isLoading) {&#10;                CircularProgressIndicator(&#10;                    modifier = Modifier.size(24.dp),&#10;                    color = MaterialTheme.colorScheme.onPrimary,&#10;                    strokeWidth = 2.dp&#10;                )&#10;            } else {&#10;                Text(&quot;Cadastrar Evento&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CategoryDropdown(&#10;    selectedCategory: EventCategory?,&#10;    onCategorySelected: (EventCategory) -&gt; Unit,&#10;    enabled: Boolean = true&#10;) {&#10;    var expanded by remember { mutableStateOf(false) }&#10;&#10;    ExposedDropdownMenuBox(&#10;        expanded = expanded,&#10;        onExpandedChange = { if (enabled) expanded = !expanded }&#10;    ) {&#10;        OutlinedTextField(&#10;            value = selectedCategory?.displayName ?: &quot;&quot;,&#10;            onValueChange = {},&#10;            readOnly = true,&#10;            enabled = enabled,&#10;            label = { Text(&quot;Categoria&quot;) },&#10;            trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded) },&#10;            modifier = Modifier&#10;                .menuAnchor()&#10;                .fillMaxWidth(),&#10;            shape = MaterialTheme.shapes.medium&#10;        )&#10;&#10;        ExposedDropdownMenu(&#10;            expanded = expanded,&#10;            onDismissRequest = { expanded = false }&#10;        ) {&#10;            EventCategory.values().forEach { category -&gt;&#10;                DropdownMenuItem(&#10;                    text = { Text(category.displayName) },&#10;                    onClick = {&#10;                        onCategorySelected(category)&#10;                        expanded = false&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ClickableOutlinedTextField(&#10;    value: String,&#10;    onClick: () -&gt; Unit,&#10;    label: String,&#10;    modifier: Modifier = Modifier,&#10;    enabled: Boolean = true&#10;) {&#10;    Box(modifier = modifier) {&#10;        OutlinedTextField(&#10;            value = value,&#10;            onValueChange = {},&#10;            label = { Text(label) },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            readOnly = true,&#10;            enabled = enabled&#10;        )&#10;        Box(&#10;            modifier = Modifier&#10;                .matchParentSize()&#10;                .clickable(enabled = enabled, onClick = onClick)&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun rememberTimePicker(context: android.content.Context, onTimeSet: (Int, Int) -&gt; Unit): TimePickerDialog {&#10;    val calendar = Calendar.getInstance()&#10;    return remember {&#10;        TimePickerDialog(&#10;            context,&#10;            { _, hour: Int, minute: Int -&gt; onTimeSet(hour, minute) },&#10;            calendar.get(Calendar.HOUR_OF_DAY),&#10;            calendar.get(Calendar.MINUTE),&#10;            true&#10;        )&#10;    }&#10;}" />
              <option name="updatedContent" value="@file:OptIn(ExperimentalMaterial3Api::class)&#10;&#10;package com.pdm.zone.ui.screens.event&#10;&#10;import android.app.DatePickerDialog&#10;import android.app.TimePickerDialog&#10;import android.net.Uri&#10;import android.widget.Toast&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.KeyboardArrowDown&#10;import androidx.compose.material.icons.filled.KeyboardArrowUp&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavHostController&#10;import coil.compose.AsyncImage&#10;import com.google.android.libraries.places.api.Places&#10;import com.google.android.libraries.places.api.model.AutocompletePrediction&#10;import com.google.android.libraries.places.api.model.Place&#10;import com.google.android.libraries.places.api.net.PlacesClient&#10;import com.google.android.libraries.places.api.net.FindAutocompletePredictionsRequest&#10;import com.google.android.libraries.places.api.net.FetchPlaceRequest&#10;import com.pdm.zone.BuildConfig&#10;import com.pdm.zone.data.model.EventCategory&#10;import com.pdm.zone.ui.components.DataField&#10;import com.pdm.zone.ui.nav.BackHeader&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;@Composable&#10;fun EventRegisterPage(&#10;    navController: NavHostController,&#10;    viewModel: EventRegisterViewModel = viewModel(),&#10;    onSubmit: () -&gt; Unit = { navController.popBackStack() },&#10;) {&#10;    val context = LocalContext.current&#10;    val uiState by viewModel.uiState.collectAsState()&#10;&#10;    var title by remember { mutableStateOf(&quot;&quot;) }&#10;    var location by remember { mutableStateOf(&quot;&quot;) }&#10;    var description by remember { mutableStateOf(&quot;&quot;) }&#10;    var imageUri by remember { mutableStateOf&lt;Uri?&gt;(null) }&#10;    var selectedCategory by remember { mutableStateOf&lt;EventCategory?&gt;(null) }&#10;&#10;    var placeId by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var latitude by remember { mutableStateOf&lt;Double?&gt;(null) }&#10;    var longitude by remember { mutableStateOf&lt;Double?&gt;(null) }&#10;    var fullAddress by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var predictions by remember { mutableStateOf&lt;List&lt;AutocompletePrediction&gt;&gt;(emptyList()) }&#10;&#10;    val selectedCalendar = remember { Calendar.getInstance() }&#10;    var dateText by remember { mutableStateOf(&quot;&quot;) }&#10;    var startTimeText by remember { mutableStateOf(&quot;&quot;) }&#10;    var endTimeText by remember { mutableStateOf(&quot;&quot;) }&#10;&#10;    val dateFormatter = remember { SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale.getDefault()) }&#10;    val timeFormatter = remember { SimpleDateFormat(&quot;HH:mm&quot;, Locale.getDefault()) }&#10;&#10;    val datePickerDialog = remember {&#10;        DatePickerDialog(&#10;            context,&#10;            { _, year: Int, month: Int, dayOfMonth: Int -&gt;&#10;                selectedCalendar.set(Calendar.YEAR, year)&#10;                selectedCalendar.set(Calendar.MONTH, month)&#10;                selectedCalendar.set(Calendar.DAY_OF_MONTH, dayOfMonth)&#10;                dateText = dateFormatter.format(selectedCalendar.time)&#10;            },&#10;            selectedCalendar.get(Calendar.YEAR),&#10;            selectedCalendar.get(Calendar.MONTH),&#10;            selectedCalendar.get(Calendar.DAY_OF_MONTH)&#10;        ).apply {&#10;            datePicker.minDate = System.currentTimeMillis()&#10;        }&#10;    }&#10;&#10;    val imagePickerLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.GetContent()&#10;    ) { uri: Uri? -&gt;&#10;        imageUri = uri&#10;    }&#10;&#10;    LaunchedEffect(uiState.isSuccess) {&#10;        if (uiState.isSuccess) {&#10;            Toast.makeText(context, &quot;Evento cadastrado com sucesso!&quot;, Toast.LENGTH_SHORT).show()&#10;            viewModel.resetState()&#10;            onSubmit()&#10;        }&#10;    }&#10;    LaunchedEffect(uiState.error) {&#10;        uiState.error?.let {&#10;            Toast.makeText(context, it, Toast.LENGTH_LONG).show()&#10;            viewModel.resetState()&#10;        }&#10;    }&#10;&#10;    // Places init&#10;    val placesClient: PlacesClient = remember {&#10;        if (!Places.isInitialized()) {&#10;            Places.initialize(context, BuildConfig.PLACES_API_KEY)&#10;        }&#10;        Places.createClient(context)&#10;    }&#10;&#10;    fun searchPlaces(query: String) {&#10;        if (query.length &lt; 3) { predictions = emptyList(); return }&#10;        val request = FindAutocompletePredictionsRequest.builder()&#10;            .setQuery(query)&#10;            .build()&#10;        placesClient.findAutocompletePredictions(request)&#10;            .addOnSuccessListener { response -&gt;&#10;                // Não altera texto do usuário, apenas mostra lista&#10;                predictions = response.autocompletePredictions&#10;            }&#10;            .addOnFailureListener { predictions = emptyList() }&#10;    }&#10;&#10;    fun fetchPlaceDetails(id: String) {&#10;        val placeRequest = FetchPlaceRequest.newInstance(id, listOf(Place.Field.ID, Place.Field.NAME, Place.Field.LAT_LNG, Place.Field.ADDRESS))&#10;        placesClient.fetchPlace(placeRequest)&#10;            .addOnSuccessListener { result -&gt;&#10;                val place = result.place&#10;                placeId = place.id&#10;                latitude = place.latLng?.latitude&#10;                longitude = place.latLng?.longitude&#10;                fullAddress = place.address&#10;            }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(rememberScrollState())&#10;            .padding(24.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    )  {&#10;        BackHeader(navController)&#10;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(180.dp)&#10;                .background(MaterialTheme.colorScheme.surfaceVariant, MaterialTheme.shapes.medium)&#10;                .clip(MaterialTheme.shapes.medium)&#10;                .clickable { imagePickerLauncher.launch(&quot;image/*&quot;) },&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            if (imageUri != null) {&#10;                AsyncImage(&#10;                    model = imageUri,&#10;                    contentDescription = &quot;Imagem do evento&quot;,&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentScale = ContentScale.Crop&#10;                )&#10;            } else {&#10;                Text(&quot;Clique para adicionar imagem&quot;, color = MaterialTheme.colorScheme.onSurfaceVariant)&#10;            }&#10;        }&#10;&#10;        DataField(value = title, onValueChange = { title = it }, label = &quot;Título&quot;, enabled = !uiState.isLoading, modifier = Modifier.fillMaxWidth())&#10;&#10;        // Campo de Local com Autocomplete&#10;        Column(modifier = Modifier.fillMaxWidth()) {&#10;            OutlinedTextField(&#10;                value = location,&#10;                onValueChange = {&#10;                    location = it&#10;                    placeId = null&#10;                    latitude = null&#10;                    longitude = null&#10;                    fullAddress = null&#10;                    searchPlaces(it)&#10;                },&#10;                label = { Text(&quot;Local&quot;) },&#10;                enabled = !uiState.isLoading,&#10;                modifier = Modifier.fillMaxWidth()&#10;            )&#10;            // Lista de sugestões (não bloqueia foco)&#10;            if (predictions.isNotEmpty()) {&#10;                Surface(&#10;                    tonalElevation = 2.dp,&#10;                    shape = MaterialTheme.shapes.medium,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(top = 4.dp)&#10;                ) {&#10;                    Column(modifier = Modifier.padding(vertical = 4.dp)) {&#10;                        predictions.take(5).forEach { prediction -&gt;&#10;                            Text(&#10;                                text = prediction.getFullText(null).toString(),&#10;                                style = MaterialTheme.typography.bodyMedium,&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .clickable {&#10;                                        // Ao selecionar, preenche e limpa lista&#10;                                        location = prediction.getFullText(null).toString()&#10;                                        fetchPlaceDetails(prediction.placeId)&#10;                                        predictions = emptyList()&#10;                                    }&#10;                                    .padding(horizontal = 12.dp, vertical = 8.dp)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            if (fullAddress != null) {&#10;                Text(fullAddress!!, style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.primary)&#10;            }&#10;        }&#10;&#10;        DataField(value = description, onValueChange = { description = it }, label = &quot;Descrição&quot;, enabled = !uiState.isLoading, modifier = Modifier.fillMaxWidth())&#10;&#10;        CategoryDropdown(&#10;            selectedCategory = selectedCategory,&#10;            onCategorySelected = { selectedCategory = it },&#10;            enabled = !uiState.isLoading&#10;        )&#10;&#10;        ClickableOutlinedTextField(value = dateText, onClick = { datePickerDialog.show() }, label = &quot;Data&quot;, enabled = !uiState.isLoading, modifier = Modifier.fillMaxWidth())&#10;&#10;        val startTimePicker = rememberTimePicker(context) { hour, minute -&gt;&#10;            selectedCalendar.set(Calendar.HOUR_OF_DAY, hour)&#10;            selectedCalendar.set(Calendar.MINUTE, minute)&#10;            startTimeText = timeFormatter.format(selectedCalendar.time)&#10;        }&#10;        val endTimePicker = rememberTimePicker(context) { hour, minute -&gt;&#10;            val endCalendar = Calendar.getInstance().apply {&#10;                time = selectedCalendar.time&#10;                set(Calendar.HOUR_OF_DAY, hour)&#10;                set(Calendar.MINUTE, minute)&#10;            }&#10;            endTimeText = timeFormatter.format(endCalendar.time)&#10;        }&#10;&#10;        Row(horizontalArrangement = Arrangement.spacedBy(16.dp), modifier = Modifier.fillMaxWidth()) {&#10;            ClickableOutlinedTextField(value = startTimeText, onClick = { startTimePicker.show() }, label = &quot;Início&quot;, modifier = Modifier.weight(1f), enabled = !uiState.isLoading)&#10;            ClickableOutlinedTextField(value = endTimeText, onClick = { endTimePicker.show() }, label = &quot;Fim&quot;, modifier = Modifier.weight(1f), enabled = !uiState.isLoading)&#10;        }&#10;&#10;        Button(&#10;            onClick = {&#10;                viewModel.createEvent(&#10;                    context = context,&#10;                    title = title,&#10;                    description = description,&#10;                    location = location,&#10;                    category = selectedCategory!!,&#10;                    imageUri = imageUri,&#10;                    eventCalendar = selectedCalendar,&#10;                    startTime = startTimeText,&#10;                    endTime = endTimeText,&#10;                    placeId = placeId,&#10;                    latitude = latitude,&#10;                    longitude = longitude,&#10;                    address = fullAddress&#10;                )&#10;            },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            enabled = !uiState.isLoading &amp;&amp; selectedCategory != null,&#10;            shape = MaterialTheme.shapes.medium&#10;        ) {&#10;            if (uiState.isLoading) {&#10;                CircularProgressIndicator(&#10;                    modifier = Modifier.size(24.dp),&#10;                    color = MaterialTheme.colorScheme.onPrimary,&#10;                    strokeWidth = 2.dp&#10;                )&#10;            } else {&#10;                Text(&quot;Cadastrar Evento&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CategoryDropdown(&#10;    selectedCategory: EventCategory?,&#10;    onCategorySelected: (EventCategory) -&gt; Unit,&#10;    enabled: Boolean = true&#10;) {&#10;    var expanded by remember { mutableStateOf(false) }&#10;&#10;    ExposedDropdownMenuBox(&#10;        expanded = expanded,&#10;        onExpandedChange = { if (enabled) expanded = !expanded }&#10;    ) {&#10;        OutlinedTextField(&#10;            value = selectedCategory?.displayName ?: &quot;&quot;,&#10;            onValueChange = {},&#10;            readOnly = true,&#10;            enabled = enabled,&#10;            label = { Text(&quot;Categoria&quot;) },&#10;            trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded) },&#10;            modifier = Modifier&#10;                .menuAnchor()&#10;                .fillMaxWidth(),&#10;            shape = MaterialTheme.shapes.medium&#10;        )&#10;&#10;        ExposedDropdownMenu(&#10;            expanded = expanded,&#10;            onDismissRequest = { expanded = false }&#10;        ) {&#10;            EventCategory.values().forEach { category -&gt;&#10;                DropdownMenuItem(&#10;                    text = { Text(category.displayName) },&#10;                    onClick = {&#10;                        onCategorySelected(category)&#10;                        expanded = false&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ClickableOutlinedTextField(&#10;    value: String,&#10;    onClick: () -&gt; Unit,&#10;    label: String,&#10;    modifier: Modifier = Modifier,&#10;    enabled: Boolean = true&#10;) {&#10;    Box(modifier = modifier) {&#10;        OutlinedTextField(&#10;            value = value,&#10;            onValueChange = {},&#10;            label = { Text(label) },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            readOnly = true,&#10;            enabled = enabled&#10;        )&#10;        Box(&#10;            modifier = Modifier&#10;                .matchParentSize()&#10;                .clickable(enabled = enabled, onClick = onClick)&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun rememberTimePicker(context: android.content.Context, onTimeSet: (Int, Int) -&gt; Unit): TimePickerDialog {&#10;    val calendar = Calendar.getInstance()&#10;    return remember {&#10;        TimePickerDialog(&#10;            context,&#10;            { _, hour: Int, minute: Int -&gt; onTimeSet(hour, minute) },&#10;            calendar.get(Calendar.HOUR_OF_DAY),&#10;            calendar.get(Calendar.MINUTE),&#10;            true&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/event/EventRegisterViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/event/EventRegisterViewModel.kt" />
              <option name="originalContent" value="package com.pdm.zone.ui.screens.event&#10;&#10;import android.R.attr.category&#10;import android.content.Context&#10;import android.graphics.Bitmap&#10;import android.net.Uri&#10;import android.os.Build&#10;import android.provider.MediaStore&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.storage.FirebaseStorage&#10;import com.pdm.zone.data.model.Event&#10;import com.pdm.zone.data.model.EventCategory&#10;import com.pdm.zone.data.model.User&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;import kotlinx.coroutines.withContext&#10;import java.io.ByteArrayOutputStream&#10;import java.util.Calendar&#10;import java.util.UUID&#10;&#10;data class EventRegisterUiState(&#10;    val isLoading: Boolean = false,&#10;    val isSuccess: Boolean = false,&#10;    val error: String? = null&#10;)&#10;&#10;class EventRegisterViewModel : ViewModel() {&#10;&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val storage = FirebaseStorage.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _uiState = MutableStateFlow(EventRegisterUiState())&#10;    val uiState = _uiState.asStateFlow()&#10;&#10;    private val MAX_IMAGE_DIMENSION = 1280.0f&#10;&#10;    fun createEvent(&#10;        context: Context,&#10;        title: String,&#10;        description: String,&#10;        location: String,&#10;        imageUri: Uri?,&#10;        category: EventCategory,&#10;        eventCalendar: Calendar,&#10;        startTime: String,&#10;        endTime: String&#10;    ) {&#10;        if (title.isBlank() || description.isBlank() || location.isBlank() || imageUri == null || startTime.isBlank() || endTime.isBlank()) {&#10;            _uiState.update { it.copy(error = &quot;Por favor, preencha todos os campos e selecione uma imagem.&quot;) }&#10;            return&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            _uiState.update { it.copy(isLoading = true, error = null) }&#10;            try {&#10;                val currentUser = auth.currentUser ?: throw IllegalStateException(&quot;Nenhum usuário logado.&quot;)&#10;                val userDoc = db.collection(&quot;users&quot;).document(currentUser.uid).get().await()&#10;                val creatorUsername = userDoc.toObject(User::class.java)?.username ?: &quot;usuário_anônimo&quot;&#10;&#10;                val imageUrl = resizeAndUploadImage(context, imageUri)&#10;&#10;                val newEvent = Event(&#10;                    title = title,&#10;                    description = description,&#10;                    location = location,&#10;                    category = category,&#10;                    imageUrl = imageUrl,&#10;                    creatorId = currentUser.uid,&#10;                    creatorUsername = creatorUsername,&#10;                    eventDate = eventCalendar.time,&#10;                    startTime = startTime,&#10;                    endTime = endTime&#10;                )&#10;&#10;                db.collection(&quot;events&quot;).add(newEvent).await()&#10;                _uiState.update { it.copy(isLoading = false, isSuccess = true) }&#10;&#10;            } catch (e: Exception) {&#10;                _uiState.update { it.copy(isLoading = false, error = &quot;Falha ao criar evento: ${e.message}&quot;) }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun resizeAndUploadImage(context: Context, imageUri: Uri): String {&#10;        // Executa a manipulação de bitmap em uma thread de background (I/O)&#10;        val imageBytes = withContext(Dispatchers.IO) {&#10;            // 1. Converte a Uri para Bitmap&#10;            val originalBitmap = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) {&#10;                android.graphics.ImageDecoder.decodeBitmap(android.graphics.ImageDecoder.createSource(context.contentResolver, imageUri))&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                MediaStore.Images.Media.getBitmap(context.contentResolver, imageUri)&#10;            }&#10;&#10;            // 2. Calcula as novas dimensões mantendo a proporção&#10;            val width = originalBitmap.width&#10;            val height = originalBitmap.height&#10;            val scaleRatio = if (width &gt; height) MAX_IMAGE_DIMENSION / width else MAX_IMAGE_DIMENSION / height&#10;            val newWidth = (width * scaleRatio).toInt()&#10;            val newHeight = (height * scaleRatio).toInt()&#10;&#10;            // 3. Cria um novo Bitmap redimensionado&#10;            val resizedBitmap = Bitmap.createScaledBitmap(originalBitmap, newWidth, newHeight, true)&#10;&#10;            // 4. Comprime o Bitmap em um ByteArray&#10;            val outputStream = ByteArrayOutputStream()&#10;            resizedBitmap.compress(Bitmap.CompressFormat.JPEG, 85, outputStream) // Qualidade 85%&#10;            outputStream.toByteArray()&#10;        }&#10;&#10;        // 5. Faz o upload do ByteArray para o Storage&#10;        val storageRef = storage.reference.child(&quot;event_images/${UUID.randomUUID()}.jpg&quot;)&#10;        storageRef.putBytes(imageBytes).await()&#10;        return storageRef.downloadUrl.await().toString()&#10;    }&#10;&#10;    fun resetState() {&#10;        _uiState.update { EventRegisterUiState() }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.pdm.zone.ui.screens.event&#10;&#10;import android.R.attr.category&#10;import android.content.Context&#10;import android.graphics.Bitmap&#10;import android.net.Uri&#10;import android.os.Build&#10;import android.provider.MediaStore&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.storage.FirebaseStorage&#10;import com.pdm.zone.data.model.Event&#10;import com.pdm.zone.data.model.EventCategory&#10;import com.pdm.zone.data.model.User&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;import kotlinx.coroutines.withContext&#10;import java.io.ByteArrayOutputStream&#10;import java.util.Calendar&#10;import java.util.UUID&#10;&#10;data class EventRegisterUiState(&#10;    val isLoading: Boolean = false,&#10;    val isSuccess: Boolean = false,&#10;    val error: String? = null&#10;)&#10;&#10;class EventRegisterViewModel : ViewModel() {&#10;&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val storage = FirebaseStorage.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _uiState = MutableStateFlow(EventRegisterUiState())&#10;    val uiState = _uiState.asStateFlow()&#10;&#10;    private val MAX_IMAGE_DIMENSION = 1280.0f&#10;&#10;    fun createEvent(&#10;        context: Context,&#10;        title: String,&#10;        description: String,&#10;        location: String,&#10;        imageUri: Uri?,&#10;        category: EventCategory,&#10;        eventCalendar: Calendar,&#10;        startTime: String,&#10;        endTime: String,&#10;        placeId: String?,&#10;        latitude: Double?,&#10;        longitude: Double?,&#10;        address: String?&#10;    ) {&#10;        if (title.isBlank() || description.isBlank() || location.isBlank() || imageUri == null || startTime.isBlank() || endTime.isBlank()) {&#10;            _uiState.update { it.copy(error = &quot;Por favor, preencha todos os campos e selecione uma imagem.&quot;) }&#10;            return&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            _uiState.update { it.copy(isLoading = true, error = null) }&#10;            try {&#10;                val currentUser = auth.currentUser ?: throw IllegalStateException(&quot;Nenhum usuário logado.&quot;)&#10;                val userDoc = db.collection(&quot;users&quot;).document(currentUser.uid).get().await()&#10;                val creatorUsername = userDoc.toObject(User::class.java)?.username ?: &quot;usuário_anônimo&quot;&#10;&#10;                val imageUrl = resizeAndUploadImage(context, imageUri)&#10;&#10;                val newEvent = Event(&#10;                    title = title,&#10;                    description = description,&#10;                    location = location,&#10;                    category = category,&#10;                    imageUrl = imageUrl,&#10;                    creatorId = currentUser.uid,&#10;                    creatorUsername = creatorUsername,&#10;                    eventDate = eventCalendar.time,&#10;                    startTime = startTime,&#10;                    endTime = endTime,&#10;                    placeId = placeId,&#10;                    latitude = latitude,&#10;                    longitude = longitude,&#10;                    address = address&#10;                )&#10;&#10;                db.collection(&quot;events&quot;).add(newEvent).await()&#10;                _uiState.update { it.copy(isLoading = false, isSuccess = true) }&#10;&#10;            } catch (e: Exception) {&#10;                _uiState.update { it.copy(isLoading = false, error = &quot;Falha ao criar evento: ${e.message}&quot;) }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun resizeAndUploadImage(context: Context, imageUri: Uri): String {&#10;        // Executa a manipulação de bitmap em uma thread de background (I/O)&#10;        val imageBytes = withContext(Dispatchers.IO) {&#10;            // 1. Converte a Uri para Bitmap&#10;            val originalBitmap = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) {&#10;                android.graphics.ImageDecoder.decodeBitmap(android.graphics.ImageDecoder.createSource(context.contentResolver, imageUri))&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                MediaStore.Images.Media.getBitmap(context.contentResolver, imageUri)&#10;            }&#10;&#10;            // 2. Calcula as novas dimensões mantendo a proporção&#10;            val width = originalBitmap.width&#10;            val height = originalBitmap.height&#10;            val scaleRatio = if (width &gt; height) MAX_IMAGE_DIMENSION / width else MAX_IMAGE_DIMENSION / height&#10;            val newWidth = (width * scaleRatio).toInt()&#10;            val newHeight = (height * scaleRatio).toInt()&#10;&#10;            // 3. Cria um novo Bitmap redimensionado&#10;            val resizedBitmap = Bitmap.createScaledBitmap(originalBitmap, newWidth, newHeight, true)&#10;&#10;            // 4. Comprime o Bitmap em um ByteArray&#10;            val outputStream = ByteArrayOutputStream()&#10;            resizedBitmap.compress(Bitmap.CompressFormat.JPEG, 85, outputStream) // Qualidade 85%&#10;            outputStream.toByteArray()&#10;        }&#10;&#10;        // 5. Faz o upload do ByteArray para o Storage&#10;        val storageRef = storage.reference.child(&quot;event_images/${UUID.randomUUID()}.jpg&quot;)&#10;        storageRef.putBytes(imageBytes).await()&#10;        return storageRef.downloadUrl.await().toString()&#10;    }&#10;&#10;    fun resetState() {&#10;        _uiState.update { EventRegisterUiState() }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/home/Home.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/home/Home.kt" />
              <option name="originalContent" value="package com.pdm.zone.ui.screens.home&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavHostController&#10;import com.pdm.zone.data.model.EventCategory&#10;import com.pdm.zone.ui.components.EventCard&#10;import com.pdm.zone.ui.theme.Primary&#10;import com.pdm.zone.ui.nav.Route&#10;&#10;@Composable&#10;fun HomePage(&#10;    navController: NavHostController,&#10;    viewModel: HomeViewModel = viewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsState()&#10;    var selectedCategory by remember { mutableStateOf&lt;EventCategory?&gt;(null) }&#10;&#10;    // Efeito para atualizar eventos quando a tela é recomposta&#10;    LaunchedEffect(Unit) {&#10;        viewModel.loadEvents()&#10;    }&#10;&#10;    Scaffold { innerPadding -&gt;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(innerPadding)&#10;        ) {&#10;            when {&#10;                uiState.isLoading -&gt; {&#10;                    CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))&#10;                }&#10;                uiState.error != null -&gt; {&#10;                    Text(&#10;                        text = uiState.error!!,&#10;                        modifier = Modifier.align(Alignment.Center)&#10;                    )&#10;                }&#10;                else -&gt; {&#10;                    LazyColumn(&#10;                        contentPadding = PaddingValues(bottom = 16.dp)&#10;                    ) {&#10;                        // Filtros de categoria&#10;                        item {&#10;                            LazyRow(&#10;                                horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                                contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp)&#10;                            ) {&#10;                                items(EventCategory.values()) { category -&gt;&#10;                                    FilterChip(&#10;                                        selected = selectedCategory == category,&#10;                                        onClick = {&#10;                                            selectedCategory = if (selectedCategory == category) null else category&#10;                                        },&#10;                                        label = { Text(category.displayName) }&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;&#10;                        // Título da página&#10;                        item {&#10;                            Text(&#10;                                text = &quot;Próximos Eventos&quot;,&#10;                                fontWeight = FontWeight.Bold,&#10;                                fontSize = 24.sp,&#10;                                color = Primary,&#10;                                modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp)&#10;                            )&#10;                        }&#10;&#10;                        // Botão para ver eventos confirmados&#10;                        item {&#10;                            Button(&#10;                                onClick = { navController.navigate(Route.List.toString()) },&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(horizontal = 16.dp, vertical = 8.dp),&#10;                                colors = ButtonDefaults.buttonColors(&#10;                                    containerColor = Primary&#10;                                )&#10;                            ) {&#10;                                Text(&quot;Ver meus eventos confirmados&quot;)&#10;                            }&#10;&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                        }&#10;&#10;                        // Lista de eventos próximos filtrados&#10;                        val filteredEvents = selectedCategory?.let { cat -&gt;&#10;                            uiState.upcomingEvents.filter { it.category == cat }&#10;                        } ?: uiState.upcomingEvents&#10;&#10;                        if (filteredEvents.isEmpty()) {&#10;                            item {&#10;                                Box(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .height(100.dp),&#10;                                    contentAlignment = Alignment.Center&#10;                                ) {&#10;                                    Text(&#10;                                        text = &quot;Nenhum evento encontrado&quot;,&#10;                                        color = Color.Gray&#10;                                    )&#10;                                }&#10;                            }&#10;                        } else {&#10;                            items(filteredEvents) { event -&gt;&#10;                                EventCard(&#10;                                    event = event,&#10;                                    onCardClick = {&#10;                                        navController.navigate(&quot;eventDetails/${it.id}&quot;)&#10;                                    }&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.pdm.zone.ui.screens.home&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavHostController&#10;import com.pdm.zone.data.model.EventCategory&#10;import com.pdm.zone.ui.components.EventCard&#10;import com.pdm.zone.ui.theme.Primary&#10;&#10;@Composable&#10;fun HomePage(&#10;    navController: NavHostController,&#10;    viewModel: HomeViewModel = viewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsState()&#10;    var selectedCategory by remember { mutableStateOf&lt;EventCategory?&gt;(null) }&#10;&#10;    // Efeito para atualizar eventos quando a tela é recomposta&#10;    LaunchedEffect(Unit) {&#10;        viewModel.loadEvents()&#10;    }&#10;&#10;    Scaffold { innerPadding -&gt;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(innerPadding)&#10;        ) {&#10;            when {&#10;                uiState.isLoading -&gt; {&#10;                    CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))&#10;                }&#10;                uiState.error != null -&gt; {&#10;                    Text(&#10;                        text = uiState.error!!,&#10;                        modifier = Modifier.align(Alignment.Center)&#10;                    )&#10;                }&#10;                else -&gt; {&#10;                    LazyColumn(&#10;                        contentPadding = PaddingValues(bottom = 16.dp)&#10;                    ) {&#10;                        // Filtros de categoria&#10;                        item {&#10;                            LazyRow(&#10;                                horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                                contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp)&#10;                            ) {&#10;                                items(EventCategory.values()) { category -&gt;&#10;                                    FilterChip(&#10;                                        selected = selectedCategory == category,&#10;                                        onClick = {&#10;                                            selectedCategory = if (selectedCategory == category) null else category&#10;                                        },&#10;                                        label = { Text(category.displayName) }&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;&#10;                        // Título da página&#10;                        item {&#10;                            Text(&#10;                                text = &quot;Próximos Eventos&quot;,&#10;                                fontWeight = FontWeight.Bold,&#10;                                fontSize = 24.sp,&#10;                                color = Primary,&#10;                                modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp)&#10;                            )&#10;                        }&#10;&#10;                        // Lista de eventos próximos filtrados&#10;                        val filteredEvents = selectedCategory?.let { cat -&gt;&#10;                            uiState.upcomingEvents.filter { it.category == cat }&#10;                        } ?: uiState.upcomingEvents&#10;&#10;                        if (filteredEvents.isEmpty()) {&#10;                            item {&#10;                                Box(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .height(100.dp),&#10;                                    contentAlignment = Alignment.Center&#10;                                ) {&#10;                                    Text(&#10;                                        text = &quot;Nenhum evento encontrado&quot;,&#10;                                        color = Color.Gray&#10;                                    )&#10;                                }&#10;                            }&#10;                        } else {&#10;                            items(filteredEvents) { event -&gt;&#10;                                EventCard(&#10;                                    event = event,&#10;                                    onCardClick = {&#10;                                        navController.navigate(&quot;eventDetails/${it.id}&quot;)&#10;                                    }&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/home/HomeViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/home/HomeViewModel.kt" />
              <option name="originalContent" value="package com.pdm.zone.ui.screens.home&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.Query&#10;import com.pdm.zone.data.model.Event&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;import java.util.Date&#10;&#10;data class HomeUiState(&#10;    val isLoading: Boolean = true,&#10;    val upcomingEvents: List&lt;Event&gt; = emptyList(),&#10;    val pastEvents: List&lt;Event&gt; = emptyList(),&#10;    val userConfirmedEvents: List&lt;Event&gt; = emptyList(), // Eventos que o usuário confirmou presença&#10;    val error: String? = null&#10;)&#10;&#10;class HomeViewModel : ViewModel() {&#10;&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _uiState = MutableStateFlow(HomeUiState())&#10;    val uiState = _uiState.asStateFlow()&#10;&#10;    init {&#10;        loadEvents()&#10;    }&#10;&#10;    fun loadEvents() {&#10;        viewModelScope.launch {&#10;            _uiState.update { it.copy(isLoading = true) }&#10;            try {&#10;                val currentUserId = auth.currentUser?.uid&#10;                if (currentUserId == null) {&#10;                    _uiState.update { it.copy(isLoading = false, error = &quot;Usuário não autenticado&quot;) }&#10;                    return@launch&#10;                }&#10;&#10;                // Carregar todos os eventos&#10;                val allEventsSnapshot = db.collection(&quot;events&quot;)&#10;                    .orderBy(&quot;eventDate&quot;, Query.Direction.ASCENDING)&#10;                    .get()&#10;                    .await()&#10;&#10;                val allEvents = allEventsSnapshot.toObjects(Event::class.java)&#10;&#10;                // Carregar eventos que o usuário confirmou presença&#10;                val userEventsSnapshot = db.collection(&quot;events&quot;)&#10;                    .whereArrayContains(&quot;attendees&quot;, currentUserId)&#10;                    .get()&#10;                    .await()&#10;&#10;                val userEvents = userEventsSnapshot.toObjects(Event::class.java)&#10;&#10;                // Separar eventos por data (passados e futuros)&#10;                val currentDate = Date()&#10;                val (upcoming, past) = allEvents.partition { event -&gt;&#10;                    event.eventDate?.after(currentDate) ?: false&#10;                }&#10;&#10;                // Separar os eventos confirmados do usuário entre futuros e passados&#10;                val userConfirmedEvents = userEvents.filter { event -&gt;&#10;                    event.eventDate?.after(currentDate) ?: false&#10;                }&#10;&#10;                _uiState.update {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        upcomingEvents = upcoming,&#10;                        pastEvents = past,&#10;                        userConfirmedEvents = userConfirmedEvents&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.update {&#10;                    it.copy(&#10;                        isLoading = false,&#10;                        error = &quot;Falha ao carregar eventos: ${e.message}&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Chamado quando o usuário confirma/cancela presença em um evento na tela de detalhes&#10;    fun refreshEvents() {&#10;        loadEvents()&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.pdm.zone.ui.screens.home&#13;&#10;&#13;&#10;import androidx.lifecycle.ViewModel&#13;&#10;import androidx.lifecycle.viewModelScope&#13;&#10;import com.google.firebase.auth.FirebaseAuth&#13;&#10;import com.google.firebase.firestore.FirebaseFirestore&#13;&#10;import com.google.firebase.firestore.Query&#13;&#10;import com.pdm.zone.data.model.Event&#13;&#10;import kotlinx.coroutines.flow.MutableStateFlow&#13;&#10;import kotlinx.coroutines.flow.asStateFlow&#13;&#10;import kotlinx.coroutines.flow.update&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;import kotlinx.coroutines.tasks.await&#13;&#10;import java.util.Date&#13;&#10;&#13;&#10;data class HomeUiState(&#13;&#10;    val isLoading: Boolean = true,&#13;&#10;    val upcomingEvents: List&lt;Event&gt; = emptyList(),&#13;&#10;    val error: String? = null&#13;&#10;)&#13;&#10;&#13;&#10;class HomeViewModel : ViewModel() {&#13;&#10;&#13;&#10;    private val db = FirebaseFirestore.getInstance()&#13;&#10;    private val auth = FirebaseAuth.getInstance()&#13;&#10;&#13;&#10;    private val _uiState = MutableStateFlow(HomeUiState())&#13;&#10;    val uiState = _uiState.asStateFlow()&#13;&#10;&#13;&#10;    init {&#13;&#10;        loadEvents()&#13;&#10;    }&#13;&#10;&#13;&#10;    fun loadEvents() {&#13;&#10;        viewModelScope.launch {&#13;&#10;            _uiState.update { it.copy(isLoading = true) }&#13;&#10;            try {&#13;&#10;                // Carregar todos os eventos&#13;&#10;                val allEventsSnapshot = db.collection(&quot;events&quot;)&#13;&#10;                    .orderBy(&quot;eventDate&quot;, Query.Direction.ASCENDING)&#13;&#10;                    .get()&#13;&#10;                    .await()&#13;&#10;&#13;&#10;                val allEvents = allEventsSnapshot.toObjects(Event::class.java)&#13;&#10;&#13;&#10;                // Separar eventos por data (apenas eventos futuros)&#13;&#10;                val currentDate = Date()&#13;&#10;                val upcomingEvents = allEvents.filter { event -&gt;&#13;&#10;                    event.eventDate?.after(currentDate) ?: false&#13;&#10;                }&#13;&#10;&#13;&#10;                _uiState.update {&#13;&#10;                    it.copy(&#13;&#10;                        isLoading = false,&#13;&#10;                        upcomingEvents = upcomingEvents&#13;&#10;                    )&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                _uiState.update {&#13;&#10;                    it.copy(&#13;&#10;                        isLoading = false,&#13;&#10;                        error = &quot;Falha ao carregar eventos: ${e.message}&quot;&#13;&#10;                    )&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Chamado quando o usuário confirma/cancela presença em um evento na tela de detalhes&#13;&#10;    fun refreshEvents() {&#13;&#10;        loadEvents()&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/user/ProfileViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/user/ProfileViewModel.kt" />
              <option name="originalContent" value="package com.pdm.zone.ui.screens.user&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FieldValue&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.pdm.zone.data.model.User&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;&#10;data class ProfileUiState(&#10;    val user: User? = null,&#10;    val isLoading: Boolean = true,&#10;    val isCurrentUserProfile: Boolean = false,&#10;    val isFollowing: Boolean = false,&#10;    val error: String? = null&#10;)&#10;&#10;class ProfileViewModel : ViewModel() {&#10;&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _uiState = MutableStateFlow(ProfileUiState())&#10;    val uiState: StateFlow&lt;ProfileUiState&gt; = _uiState.asStateFlow()&#10;&#10;    fun loadUserProfile(username: String) {&#10;        viewModelScope.launch {&#10;            _uiState.update { it.copy(isLoading = true, error = null) }&#10;            try {&#10;                val currentUserId = auth.currentUser?.uid&#10;                if (currentUserId == null) {&#10;                    _uiState.update { it.copy(isLoading = false, error = &quot;Usuário não autenticado.&quot;) }&#10;                    return@launch&#10;                }&#10;&#10;                val querySnapshot = db.collection(&quot;users&quot;)&#10;                    .whereEqualTo(&quot;username&quot;, username)&#10;                    .get()&#10;                    .await()&#10;&#10;                if (querySnapshot.isEmpty) {&#10;                    _uiState.update { it.copy(isLoading = false, error = &quot;Usuário não encontrado.&quot;) }&#10;                    return@launch&#10;                }&#10;&#10;                val userDocument = querySnapshot.documents.first()&#10;                val profileUser = userDocument.toObject(User::class.java)?.copy(uid = userDocument.id)&#10;&#10;                if (profileUser == null) {&#10;                    _uiState.update { it.copy(isLoading = false, error = &quot;Falha ao ler dados do perfil.&quot;) }&#10;                    return@launch&#10;                }&#10;&#10;                val isCurrentUserProfile = profileUser.uid == currentUserId&#10;                val isFollowing = profileUser.followers.contains(currentUserId)&#10;&#10;                _uiState.update {&#10;                    it.copy(&#10;                        user = profileUser,&#10;                        isCurrentUserProfile = isCurrentUserProfile,&#10;                        isFollowing = isFollowing,&#10;                        isLoading = false&#10;                    )&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                _uiState.update { it.copy(isLoading = false, error = &quot;Erro ao carregar perfil: ${e.message}&quot;) }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun toggleFollow() {&#10;        viewModelScope.launch {&#10;            val profileUser = _uiState.value.user ?: return@launch&#10;            val currentUser = auth.currentUser ?: return@launch&#10;&#10;            val isCurrentlyFollowing = _uiState.value.isFollowing&#10;&#10;            try {&#10;                // 1. Atualizar o estado UI imediatamente para feedback instantâneo&#10;                val updatedFollowersList = profileUser.followers.toMutableList()&#10;&#10;                if (isCurrentlyFollowing) {&#10;                    updatedFollowersList.remove(currentUser.uid)&#10;                } else {&#10;                    updatedFollowersList.add(currentUser.uid)&#10;                }&#10;&#10;                // Criar uma cópia atualizada do user com a nova lista de seguidores&#10;                val updatedUser = profileUser.copy(followers = updatedFollowersList)&#10;&#10;                // Atualizar o estado com o user modificado e o novo status de isFollowing&#10;                _uiState.update {&#10;                    it.copy(&#10;                        user = updatedUser,&#10;                        isFollowing = !isCurrentlyFollowing&#10;                    )&#10;                }&#10;&#10;                // 2. Persistir as mudanças no Firestore&#10;                val currentUserRef = db.collection(&quot;users&quot;).document(currentUser.uid)&#10;                val profileUserRef = db.collection(&quot;users&quot;).document(profileUser.uid)&#10;&#10;                if (isCurrentlyFollowing) {&#10;                    currentUserRef.update(&quot;following&quot;, FieldValue.arrayRemove(profileUser.uid))&#10;                    profileUserRef.update(&quot;followers&quot;, FieldValue.arrayRemove(currentUser.uid))&#10;                } else {&#10;                    currentUserRef.update(&quot;following&quot;, FieldValue.arrayUnion(profileUser.uid))&#10;                    profileUserRef.update(&quot;followers&quot;, FieldValue.arrayUnion(currentUser.uid))&#10;                }&#10;            } catch(e: Exception) {&#10;                // Em caso de erro, reverter para o estado anterior&#10;                _uiState.update { it.copy(isFollowing = isCurrentlyFollowing, error = &quot;Ocorreu um erro ao atualizar.&quot;) }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.pdm.zone.ui.screens.user&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FieldValue&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.pdm.zone.data.model.User&#10;import com.pdm.zone.data.model.Event&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;import java.util.Date&#10;&#10;data class ProfileUiState(&#10;    val user: User? = null,&#10;    val isLoading: Boolean = true,&#10;    val isCurrentUserProfile: Boolean = false,&#10;    val isFollowing: Boolean = false,&#10;    val error: String? = null,&#10;    val upcomingEvents: List&lt;Event&gt; = emptyList(),&#10;    val pastEvents: List&lt;Event&gt; = emptyList(),&#10;    val isLoadingEvents: Boolean = false&#10;)&#10;&#10;class ProfileViewModel : ViewModel() {&#10;&#10;    private val db = FirebaseFirestore.getInstance()&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    private val _uiState = MutableStateFlow(ProfileUiState())&#10;    val uiState: StateFlow&lt;ProfileUiState&gt; = _uiState.asStateFlow()&#10;&#10;    fun loadUserProfile(username: String) {&#10;        viewModelScope.launch {&#10;            _uiState.update { it.copy(isLoading = true, error = null) }&#10;            try {&#10;                val currentUserId = auth.currentUser?.uid&#10;                if (currentUserId == null) {&#10;                    _uiState.update { it.copy(isLoading = false, error = &quot;Usuário não autenticado.&quot;) }&#10;                    return@launch&#10;                }&#10;&#10;                val querySnapshot = db.collection(&quot;users&quot;)&#10;                    .whereEqualTo(&quot;username&quot;, username)&#10;                    .get()&#10;                    .await()&#10;&#10;                if (querySnapshot.isEmpty) {&#10;                    _uiState.update { it.copy(isLoading = false, error = &quot;Usuário não encontrado.&quot;) }&#10;                    return@launch&#10;                }&#10;&#10;                val userDocument = querySnapshot.documents.first()&#10;                val profileUser = userDocument.toObject(User::class.java)?.copy(uid = userDocument.id)&#10;&#10;                if (profileUser == null) {&#10;                    _uiState.update { it.copy(isLoading = false, error = &quot;Falha ao ler dados do perfil.&quot;) }&#10;                    return@launch&#10;                }&#10;&#10;                val isCurrentUserProfile = profileUser.uid == currentUserId&#10;                val isFollowing = profileUser.followers.contains(currentUserId)&#10;&#10;                _uiState.update {&#10;                    it.copy(&#10;                        user = profileUser,&#10;                        isCurrentUserProfile = isCurrentUserProfile,&#10;                        isFollowing = isFollowing,&#10;                        isLoading = false&#10;                    )&#10;                }&#10;                &#10;                // Carregar eventos do usuário&#10;                loadUserEvents(profileUser.uid)&#10;&#10;            } catch (e: Exception) {&#10;                _uiState.update { it.copy(isLoading = false, error = &quot;Erro ao carregar perfil: ${e.message}&quot;) }&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun loadUserEvents(userId: String) {&#10;        viewModelScope.launch {&#10;            _uiState.update { it.copy(isLoadingEvents = true) }&#10;            try {&#10;                val eventsSnapshot = db.collection(&quot;events&quot;)&#10;                    .whereArrayContains(&quot;attendees&quot;, userId)&#10;                    .get()&#10;                    .await()&#10;                    &#10;                val allEvents = eventsSnapshot.documents.mapNotNull { doc -&gt;&#10;                    doc.toObject(Event::class.java)&#10;                }&#10;                &#10;                val currentDate = Date()&#10;                val (upcoming, past) = allEvents.partition { event -&gt;&#10;                    event.eventDate?.after(currentDate) ?: false&#10;                }&#10;                &#10;                _uiState.update { &#10;                    it.copy(&#10;                        upcomingEvents = upcoming,&#10;                        pastEvents = past,&#10;                        isLoadingEvents = false&#10;                    )&#10;                }&#10;                &#10;            } catch (e: Exception) {&#10;                _uiState.update { &#10;                    it.copy(&#10;                        isLoadingEvents = false,&#10;                        error = &quot;Erro ao carregar eventos: ${e.message}&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun toggleFollow() {&#10;        viewModelScope.launch {&#10;            val profileUser = _uiState.value.user ?: return@launch&#10;            val currentUser = auth.currentUser ?: return@launch&#10;&#10;            val isCurrentlyFollowing = _uiState.value.isFollowing&#10;&#10;            try {&#10;                // 1. Atualizar o estado UI imediatamente para feedback instantâneo&#10;                val updatedFollowersList = profileUser.followers.toMutableList()&#10;                &#10;                if (isCurrentlyFollowing) {&#10;                    updatedFollowersList.remove(currentUser.uid)&#10;                } else {&#10;                    updatedFollowersList.add(currentUser.uid)&#10;                }&#10;                &#10;                // Criar uma cópia atualizada do user com a nova lista de seguidores&#10;                val updatedUser = profileUser.copy(followers = updatedFollowersList)&#10;                &#10;                // Atualizar o estado com o user modificado e o novo status de isFollowing&#10;                _uiState.update { &#10;                    it.copy(&#10;                        user = updatedUser,&#10;                        isFollowing = !isCurrentlyFollowing&#10;                    ) &#10;                }&#10;&#10;                // 2. Persistir as mudanças no Firestore&#10;                val currentUserRef = db.collection(&quot;users&quot;).document(currentUser.uid)&#10;                val profileUserRef = db.collection(&quot;users&quot;).document(profileUser.uid)&#10;&#10;                if (isCurrentlyFollowing) {&#10;                    currentUserRef.update(&quot;following&quot;, FieldValue.arrayRemove(profileUser.uid))&#10;                    profileUserRef.update(&quot;followers&quot;, FieldValue.arrayRemove(currentUser.uid))&#10;                } else {&#10;                    currentUserRef.update(&quot;following&quot;, FieldValue.arrayUnion(profileUser.uid))&#10;                    profileUserRef.update(&quot;followers&quot;, FieldValue.arrayUnion(currentUser.uid))&#10;                }&#10;            } catch(e: Exception) {&#10;                // Em caso de erro, reverter para o estado anterior&#10;                _uiState.update { it.copy(isFollowing = isCurrentlyFollowing, error = &quot;Ocorreu um erro ao atualizar.&quot;) }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/user/UserCreatedEventList.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/user/UserCreatedEventList.kt" />
              <option name="originalContent" value="package com.pdm.zone.ui.screens.user&#10;&#10;import android.R.attr.navigationIcon&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.LocationOn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.navigation.NavHostController&#10;import coil.compose.AsyncImage&#10;import coil.request.ImageRequest&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.pdm.zone.R&#10;import com.pdm.zone.data.model.Event&#10;import com.pdm.zone.ui.theme.Primary&#10;import kotlinx.coroutines.tasks.await&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun UserCreatedEventList(&#10;    username: String?,&#10;    modifier: Modifier = Modifier,&#10;    navController: NavHostController,&#10;    onClick: (String) -&gt; Unit&#10;)&#10;{&#10;    val db = FirebaseFirestore.getInstance()&#10;    var events by remember { mutableStateOf&lt;List&lt;Event&gt;&gt;(emptyList()) }&#10;    var isLoading by remember { mutableStateOf(true) }&#10;    val dateFormatter = remember { SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale(&quot;pt&quot;, &quot;BR&quot;)) }&#10;&#10;    LaunchedEffect(username) {&#10;        if (username != null) {&#10;            try {&#10;                val result = db.collection(&quot;events&quot;)&#10;                    .whereEqualTo(&quot;creatorUsername&quot;, username)&#10;                    .get()&#10;                    .await()&#10;&#10;                events = result.toObjects(Event::class.java)&#10;            } catch (e: Exception) {&#10;                e.printStackTrace()&#10;            } finally {&#10;                isLoading = false&#10;            }&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Eventos de $username&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = { navController.popBackStack() }) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Voltar&quot;,&#10;                            tint = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { padding -&gt;&#10;        Box(modifier = Modifier.padding(padding)) {&#10;            when {&#10;                isLoading -&gt; CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))&#10;                events.isEmpty() -&gt; Text(&quot;Nenhum evento encontrado.&quot;, modifier = Modifier.align(Alignment.Center))&#10;                else -&gt; LazyColumn(modifier = Modifier.fillMaxSize().padding(16.dp)) {&#10;                    items(events) { event -&gt;&#10;                        Card(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(vertical = 8.dp)&#10;                                .clickable { onClick(event.id) }&#10;                        ) {&#10;                            Row (&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(8.dp),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                // Imagem do evento&#10;                                AsyncImage(&#10;                                    model = ImageRequest.Builder(LocalContext.current)&#10;                                        .data(event.imageUrl)&#10;                                        .crossfade(true)&#10;                                        .build(),&#10;                                    placeholder = painterResource(R.drawable.placeholder_event),&#10;                                    contentDescription = event.title,&#10;                                    contentScale = ContentScale.Crop,&#10;                                    modifier = Modifier&#10;                                        .size(100.dp)&#10;                                        .padding(end = 8.dp)&#10;                                )&#10;&#10;                                // Detalhes do evento&#10;                                Column(&#10;                                    modifier = Modifier&#10;                                        .weight(1f)&#10;                                        .padding(start = 8.dp)&#10;                                ) {&#10;                                    // Título&#10;                                    Text(&#10;                                        text = event.title,&#10;                                        style = MaterialTheme.typography.titleMedium,&#10;                                        color = Primary,&#10;                                        fontWeight = FontWeight.Bold&#10;                                    )&#10;&#10;                                    // Local&#10;                                    Row(&#10;                                        verticalAlignment = Alignment.CenterVertically,&#10;                                        modifier = Modifier.padding(top = 4.dp)&#10;                                    ) {&#10;                                        Icon(&#10;                                            Icons.Default.LocationOn,&#10;                                            contentDescription = &quot;Local&quot;,&#10;                                            tint = Color.Gray,&#10;                                            modifier = Modifier.size(16.dp)&#10;                                        )&#10;                                        Spacer(modifier = Modifier.width(4.dp))&#10;                                        Text(&#10;                                            text = event.location,&#10;                                            style = MaterialTheme.typography.bodySmall,&#10;                                            color = Color.Gray&#10;                                        )&#10;                                    }&#10;&#10;                                    // Data&#10;                                    event.eventDate?.let { date -&gt;&#10;                                        Row(&#10;                                            verticalAlignment = Alignment.CenterVertically,&#10;                                            modifier = Modifier.padding(top = 4.dp)&#10;                                        ) {&#10;                                            Text(&#10;                                                text = &quot;Data:&quot;,&#10;                                                style = MaterialTheme.typography.bodySmall,&#10;                                                fontWeight = FontWeight.Bold,&#10;                                                color = Color.Gray&#10;                                            )&#10;                                            Spacer(modifier = Modifier.width(4.dp))&#10;                                            Text(&#10;                                                text = dateFormatter.format(date),&#10;                                                style = MaterialTheme.typography.bodySmall,&#10;                                                color = Color.Gray&#10;                                            )&#10;                                        }&#10;                                    }&#10;&#10;                                    // Horário&#10;                                    Row(&#10;                                        verticalAlignment = Alignment.CenterVertically,&#10;                                        modifier = Modifier.padding(top = 4.dp)&#10;                                    ) {&#10;                                        Text(&#10;                                            text = &quot;Horário:&quot;,&#10;                                            style = MaterialTheme.typography.bodySmall,&#10;                                            fontWeight = FontWeight.Bold,&#10;                                            color = Color.Gray&#10;                                        )&#10;                                        Spacer(modifier = Modifier.width(4.dp))&#10;                                        Text(&#10;                                            text = &quot;${event.startTime ?: &quot;--:--&quot;} - ${event.endTime ?: &quot;--:--&quot;}&quot;,&#10;                                            style = MaterialTheme.typography.bodySmall,&#10;                                            color = Color.Gray&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.pdm.zone.ui.screens.user&#10;&#10;import android.R.attr.navigationIcon&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.navigation.NavHostController&#10;import coil.compose.AsyncImage&#10;import coil.request.ImageRequest&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.pdm.zone.R&#10;import com.pdm.zone.data.model.Event&#10;import com.pdm.zone.ui.components.CompactEventCard&#10;import kotlinx.coroutines.tasks.await&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun UserCreatedEventList(&#10;    username: String?,&#10;    modifier: Modifier = Modifier,&#10;    navController: NavHostController,&#10;    onClick: (String) -&gt; Unit&#10;)&#10;{   &#10;    val db = FirebaseFirestore.getInstance()&#10;    var events by remember { mutableStateOf&lt;List&lt;Event&gt;&gt;(emptyList()) }&#10;    var isLoading by remember { mutableStateOf(true) }&#10;&#10;    LaunchedEffect(username) {&#10;        if (username != null) {&#10;            try {&#10;                val result = db.collection(&quot;events&quot;)&#10;                    .whereEqualTo(&quot;creatorUsername&quot;, username)&#10;                    .get()&#10;                    .await()&#10;&#10;                events = result.toObjects(Event::class.java)&#10;            } catch (e: Exception) {&#10;                e.printStackTrace()&#10;            } finally {&#10;                isLoading = false&#10;            }&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Eventos de $username&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = { navController.popBackStack() }) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Voltar&quot;,&#10;                            tint = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { padding -&gt;&#10;        Box(modifier = Modifier.padding(padding)) {&#10;            when {&#10;                isLoading -&gt; CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))&#10;                events.isEmpty() -&gt; Text(&quot;Nenhum evento encontrado.&quot;, modifier = Modifier.align(Alignment.Center))&#10;                else -&gt; LazyColumn(modifier = Modifier.fillMaxSize()) {&#10;                    items(events) { event -&gt;&#10;                        CompactEventCard(&#10;                            event = event,&#10;                            onCardClick = { &#10;                                onClick(it.id) &#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/user/UserProfile.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pdm/zone/ui/screens/user/UserProfile.kt" />
              <option name="originalContent" value="package com.pdm.zone.ui.screens.user&#10;&#10;import android.app.Activity&#10;import android.content.Intent&#10;import android.widget.Toast&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.material3.TabRowDefaults.tabIndicatorOffset&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavHostController&#10;import com.pdm.zone.data.model.User&#10;import com.pdm.zone.data.model.Event&#10;import com.pdm.zone.ui.theme.Primary&#10;import com.pdm.zone.ui.components.EventCard&#10;import coil.compose.AsyncImage&#10;import coil.request.ImageRequest&#10;import com.pdm.zone.R&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;@Composable&#10;fun ProfilePage(&#10;    navController: NavHostController,&#10;    username: String,&#10;    viewModel: ProfileViewModel = viewModel()&#10;) {&#10;&#10;    val uiState by viewModel.uiState.collectAsState()&#10;    val context = LocalContext.current&#10;&#10;    LaunchedEffect(username) {&#10;        viewModel.loadUserProfile(username)&#10;    }&#10;&#10;    LaunchedEffect(uiState.error) {&#10;        uiState.error?.let {&#10;            Toast.makeText(context, it, Toast.LENGTH_LONG).show()&#10;        }&#10;    }&#10;&#10;    if (uiState.isLoading) {&#10;        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#10;            CircularProgressIndicator()&#10;        }&#10;        return&#10;    }&#10;&#10;    if (uiState.user == null) {&#10;        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#10;            Text(uiState.error ?: &quot;Perfil não encontrado.&quot;)&#10;        }&#10;        return&#10;    }&#10;&#10;    val user = uiState.user!!&#10;    var selectedTab by remember { mutableStateOf(0) }&#10;    val tabs = listOf(&quot;Próximos eventos&quot;, &quot;Eventos passados&quot;)&#10;&#10;    LazyColumn(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color.White)&#10;    ) {&#10;        item { ProfileHeader(user) }&#10;        item { ProfileStats(user = user, navController = navController) }&#10;&#10;        if (uiState.isCurrentUserProfile) {&#10;            item { ProfileActions() }&#10;        } else {&#10;            item {&#10;                FollowActions(&#10;                    isFollowing = uiState.isFollowing,&#10;                    onClick = { viewModel.toggleFollow() }&#10;                )&#10;            }&#10;        }&#10;&#10;        item {&#10;            EventTabs(&#10;                selectedTab = selectedTab,&#10;                tabs = tabs,&#10;                onTabSelected = { selectedTab = it }&#10;            )&#10;        }&#10;&#10;        when (selectedTab) {&#10;            0 -&gt; {&#10;                if (uiState.isLoadingEvents) {&#10;                    item {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .height(200.dp),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            CircularProgressIndicator()&#10;                        }&#10;                    }&#10;                } else if (uiState.upcomingEvents.isEmpty()) {&#10;                    item {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .height(200.dp),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;Nenhum evento próximo&quot;,&#10;                                color = Color.Gray,&#10;                                fontSize = 16.sp&#10;                            )&#10;                        }&#10;                    }&#10;                } else {&#10;                    items(uiState.upcomingEvents) { event -&gt;&#10;                        EventCard(&#10;                            event = event,&#10;                            onCardClick = { navController.navigate(&quot;eventDetails/${it.id}&quot;) }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;            1 -&gt; {&#10;                if (uiState.isLoadingEvents) {&#10;                    item {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .height(200.dp),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            CircularProgressIndicator()&#10;                        }&#10;                    }&#10;                } else if (uiState.pastEvents.isEmpty()) {&#10;                    item {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .height(200.dp),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;Nenhum evento passado&quot;,&#10;                                color = Color.Gray,&#10;                                fontSize = 16.sp&#10;                            )&#10;                        }&#10;                    }&#10;                } else {&#10;                    items(uiState.pastEvents) { event -&gt;&#10;                        EventCard(&#10;                            event = event,&#10;                            onCardClick = { navController.navigate(&quot;eventDetails/${it.id}&quot;) }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ProfileStats(user: User, navController: NavHostController) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp, vertical = 8.dp),&#10;        horizontalArrangement = Arrangement.SpaceEvenly&#10;    ) {&#10;        StatItem(&#10;            count = user.following.size.toString(),&#10;            label = &quot;Seguindo&quot;,&#10;            onClick = {&#10;                navController.navigate(&quot;userList/seguindo/${user.username}&quot;)&#10;            }&#10;        )&#10;        StatItem(&#10;            count = user.followers.size.toString(),&#10;            label = &quot;Seguidores&quot;,&#10;            onClick = {&#10;                navController.navigate(&quot;userList/seguidores/${user.username}&quot;)&#10;            }&#10;        )&#10;        StatItem(&#10;            count = user.createdEvents.size.toString(),&#10;            label = &quot;Eventos criados&quot;,&#10;            onClick = {&#10;                navController.navigate(&quot;EventList/createdEvents/${user.username}&quot;)&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun FollowActions(&#10;    isFollowing: Boolean,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    Button(&#10;        onClick = onClick,&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp),&#10;        colors = ButtonDefaults.buttonColors(&#10;            containerColor = if (isFollowing) Color.Gray else Primary&#10;        ),&#10;        shape = RoundedCornerShape(8.dp)&#10;    ) {&#10;        Text(&#10;            text = if (isFollowing) &quot;Deixar de seguir&quot; else &quot;Seguir&quot;,&#10;            color = Color.White,&#10;            fontSize = 14.sp&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ProfileHeader(user: User) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(16.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        // Foto do perfil com fallback&#10;        Box(&#10;            modifier = Modifier&#10;                .size(120.dp)&#10;                .clip(CircleShape)&#10;                .background(Color.Gray.copy(alpha = 0.1f)),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            if (!user.profilePic.isNullOrBlank()) {&#10;                AsyncImage(&#10;                    model = ImageRequest.Builder(LocalContext.current)&#10;                        .data(user.profilePic)&#10;                        .crossfade(true)&#10;                        .build(),&#10;                    contentDescription = &quot;Foto do perfil&quot;,&#10;                    modifier = Modifier&#10;                        .size(120.dp)&#10;                        .clip(CircleShape)&#10;                )&#10;            } else {&#10;                Text(&#10;                    text = user.firstName.first().toString(),&#10;                    fontSize = 48.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = Color.Gray&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        Text(&#10;            text = &quot;${user.firstName} ${user.lastName}&quot;,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = Primary&#10;        )&#10;&#10;        Text(&#10;            text = user.username,&#10;            fontSize = 16.sp,&#10;            color = Color.Gray&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(12.dp))&#10;&#10;        Text(&#10;            text = user.biography ?: &quot;&quot;,&#10;            fontSize = 14.sp,&#10;            color = Color.Black,&#10;            textAlign = TextAlign.Center,&#10;            lineHeight = 20.sp&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun StatItem(count: String, label: String, onClick: (() -&gt; Unit)? = null) {&#10;    Column(&#10;        modifier = Modifier&#10;            .clickable(enabled = onClick != null) { onClick?.invoke() },&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        Text(&#10;            text = count,&#10;            fontSize = 20.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = Color.Black&#10;        )&#10;        Text(&#10;            text = label,&#10;            fontSize = 12.sp,&#10;            color = Color.Gray&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ProfileActions() {&#10;    val activity = LocalContext.current as? Activity&#10;&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp, vertical = 8.dp),&#10;        horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;    ) {&#10;        Button(&#10;            onClick = {&#10;                activity?.startActivity(Intent(activity, UserProfileEdit::class.java))&#10;            },&#10;            modifier = Modifier.weight(1f),&#10;            colors = ButtonDefaults.buttonColors(&#10;                containerColor = Primary&#10;            ),&#10;            shape = RoundedCornerShape(8.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;Editar Perfil&quot;,&#10;                color = Color.White,&#10;                fontSize = 14.sp&#10;            )&#10;        }&#10;&#10;        Button(&#10;            onClick = { /* Implementar compartilhamento */ },&#10;            modifier = Modifier.weight(1f),&#10;            colors = ButtonDefaults.buttonColors(&#10;                containerColor = Primary&#10;            ),&#10;            shape = RoundedCornerShape(8.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;Compartilhar perfil&quot;,&#10;                color = Color.White,&#10;                fontSize = 14.sp&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun EventTabs(&#10;    selectedTab: Int,&#10;    tabs: List&lt;String&gt;,&#10;    onTabSelected: (Int) -&gt; Unit&#10;) {&#10;    TabRow(&#10;        selectedTabIndex = selectedTab,&#10;        modifier = Modifier.fillMaxWidth(),&#10;        containerColor = Color.White,&#10;        contentColor = Primary,&#10;        indicator = { tabPositions -&gt;&#10;            TabRowDefaults.Indicator(&#10;                modifier = Modifier.tabIndicatorOffset(tabPositions[selectedTab]),&#10;                color = Primary&#10;            )&#10;        }&#10;    ) {&#10;        tabs.forEachIndexed { index, title -&gt;&#10;            Tab(&#10;                selected = selectedTab == index,&#10;                onClick = { onTabSelected(index) },&#10;                text = {&#10;                    Text(&#10;                        text = title,&#10;                        fontSize = 16.sp,&#10;                        fontWeight = if (selectedTab == index) FontWeight.Bold else FontWeight.Normal&#10;                    )&#10;                },&#10;                selectedContentColor = Primary,&#10;                unselectedContentColor = Color.Gray&#10;            )&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.pdm.zone.ui.screens.user&#10;&#10;import android.app.Activity&#10;import android.content.Intent&#10;import android.widget.Toast&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.material3.TabRowDefaults.tabIndicatorOffset&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavHostController&#10;import com.pdm.zone.data.model.User&#10;import com.pdm.zone.data.model.Event&#10;import com.pdm.zone.ui.theme.Primary&#10;import com.pdm.zone.ui.components.EventCard&#10;import com.pdm.zone.ui.components.CompactEventCard&#10;import coil.compose.AsyncImage&#10;import coil.request.ImageRequest&#10;import com.pdm.zone.R&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;@Composable&#10;fun ProfilePage(&#10;    navController: NavHostController,&#10;    username: String,&#10;    viewModel: ProfileViewModel = viewModel()&#10;) {&#10;&#10;    val uiState by viewModel.uiState.collectAsState()&#10;    val context = LocalContext.current&#10;&#10;    LaunchedEffect(username) {&#10;        viewModel.loadUserProfile(username)&#10;    }&#10;&#10;    LaunchedEffect(uiState.error) {&#10;        uiState.error?.let {&#10;            Toast.makeText(context, it, Toast.LENGTH_LONG).show()&#10;        }&#10;    }&#10;&#10;    if (uiState.isLoading) {&#10;        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#10;            CircularProgressIndicator()&#10;        }&#10;        return&#10;    }&#10;&#10;    if (uiState.user == null) {&#10;        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#10;            Text(uiState.error ?: &quot;Perfil não encontrado.&quot;)&#10;        }&#10;        return&#10;    }&#10;&#10;    val user = uiState.user!!&#10;    var selectedTab by remember { mutableStateOf(0) }&#10;    val tabs = listOf(&quot;Próximos eventos&quot;, &quot;Eventos passados&quot;)&#10;&#10;    LazyColumn(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color.White)&#10;    ) {&#10;        item { ProfileHeader(user) }&#10;        item { ProfileStats(user = user, navController = navController) }&#10;&#10;        if (uiState.isCurrentUserProfile) {&#10;            item { ProfileActions() }&#10;        } else {&#10;            item {&#10;                FollowActions(&#10;                    isFollowing = uiState.isFollowing,&#10;                    onClick = { viewModel.toggleFollow() }&#10;                )&#10;            }&#10;        }&#10;&#10;        item {&#10;            EventTabs(&#10;                selectedTab = selectedTab,&#10;                tabs = tabs,&#10;                onTabSelected = { selectedTab = it }&#10;            )&#10;        }&#10;&#10;        when (selectedTab) {&#10;            0 -&gt; {&#10;                if (uiState.isLoadingEvents) {&#10;                    item {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .height(200.dp),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            CircularProgressIndicator()&#10;                        }&#10;                    }&#10;                } else if (uiState.upcomingEvents.isEmpty()) {&#10;                    item {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .height(200.dp),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;Nenhum evento próximo&quot;,&#10;                                color = Color.Gray,&#10;                                fontSize = 16.sp&#10;                            )&#10;                        }&#10;                    }&#10;                } else {&#10;                    items(uiState.upcomingEvents) { event -&gt;&#10;                        CompactEventCard(&#10;                            event = event,&#10;                            onCardClick = { navController.navigate(&quot;eventDetails/${it.id}&quot;) }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;            1 -&gt; {&#10;                if (uiState.isLoadingEvents) {&#10;                    item {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .height(200.dp),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            CircularProgressIndicator()&#10;                        }&#10;                    }&#10;                } else if (uiState.pastEvents.isEmpty()) {&#10;                    item {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .height(200.dp),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;Nenhum evento passado&quot;,&#10;                                color = Color.Gray,&#10;                                fontSize = 16.sp&#10;                            )&#10;                        }&#10;                    }&#10;                } else {&#10;                    items(uiState.pastEvents) { event -&gt;&#10;                        CompactEventCard(&#10;                            event = event,&#10;                            onCardClick = { navController.navigate(&quot;eventDetails/${it.id}&quot;) }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ProfileStats(user: User, navController: NavHostController) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp, vertical = 8.dp),&#10;        horizontalArrangement = Arrangement.SpaceEvenly&#10;    ) {&#10;        StatItem(&#10;            count = user.following.size.toString(),&#10;            label = &quot;Seguindo&quot;,&#10;            onClick = {&#10;                navController.navigate(&quot;userList/seguindo/${user.username}&quot;)&#10;            }&#10;        )&#10;        StatItem(&#10;            count = user.followers.size.toString(),&#10;            label = &quot;Seguidores&quot;,&#10;            onClick = {&#10;                navController.navigate(&quot;userList/seguidores/${user.username}&quot;)&#10;            }&#10;        )&#10;        StatItem(&#10;            count = user.createdEvents.size.toString(),&#10;            label = &quot;Eventos criados&quot;,&#10;            onClick = {&#10;                navController.navigate(&quot;EventList/createdEvents/${user.username}&quot;)&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun FollowActions(&#10;    isFollowing: Boolean,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    Button(&#10;        onClick = onClick,&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp),&#10;        colors = ButtonDefaults.buttonColors(&#10;            containerColor = if (isFollowing) Color.Gray else Primary&#10;        ),&#10;        shape = RoundedCornerShape(8.dp)&#10;    ) {&#10;        Text(&#10;            text = if (isFollowing) &quot;Deixar de seguir&quot; else &quot;Seguir&quot;,&#10;            color = Color.White,&#10;            fontSize = 14.sp&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ProfileHeader(user: User) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(16.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        // Foto do perfil com fallback&#10;        Box(&#10;            modifier = Modifier&#10;                .size(120.dp)&#10;                .clip(CircleShape)&#10;                .background(Color.Gray.copy(alpha = 0.1f)),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            if (!user.profilePic.isNullOrBlank()) {&#10;                AsyncImage(&#10;                    model = ImageRequest.Builder(LocalContext.current)&#10;                        .data(user.profilePic)&#10;                        .crossfade(true)&#10;                        .build(),&#10;                    contentDescription = &quot;Foto do perfil&quot;,&#10;                    modifier = Modifier&#10;                        .size(120.dp)&#10;                        .clip(CircleShape)&#10;                )&#10;            } else {&#10;                Text(&#10;                    text = user.firstName.first().toString(),&#10;                    fontSize = 48.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = Color.Gray&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        Text(&#10;            text = &quot;${user.firstName} ${user.lastName}&quot;,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = Primary&#10;        )&#10;&#10;        Text(&#10;            text = user.username,&#10;            fontSize = 16.sp,&#10;            color = Color.Gray&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(12.dp))&#10;&#10;        Text(&#10;            text = user.biography ?: &quot;&quot;,&#10;            fontSize = 14.sp,&#10;            color = Color.Black,&#10;            textAlign = TextAlign.Center,&#10;            lineHeight = 20.sp&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun StatItem(count: String, label: String, onClick: (() -&gt; Unit)? = null) {&#10;    Column(&#10;        modifier = Modifier&#10;            .clickable(enabled = onClick != null) { onClick?.invoke() },&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        Text(&#10;            text = count,&#10;            fontSize = 20.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = Color.Black&#10;        )&#10;        Text(&#10;            text = label,&#10;            fontSize = 12.sp,&#10;            color = Color.Gray&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ProfileActions() {&#10;    val activity = LocalContext.current as? Activity&#10;&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp, vertical = 8.dp),&#10;        horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;    ) {&#10;        Button(&#10;            onClick = {&#10;                activity?.startActivity(Intent(activity, UserProfileEdit::class.java))&#10;            },&#10;            modifier = Modifier.weight(1f),&#10;            colors = ButtonDefaults.buttonColors(&#10;                containerColor = Primary&#10;            ),&#10;            shape = RoundedCornerShape(8.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;Editar Perfil&quot;,&#10;                color = Color.White,&#10;                fontSize = 14.sp&#10;            )&#10;        }&#10;&#10;        Button(&#10;            onClick = { /* Implementar compartilhamento */ },&#10;            modifier = Modifier.weight(1f),&#10;            colors = ButtonDefaults.buttonColors(&#10;                containerColor = Primary&#10;            ),&#10;            shape = RoundedCornerShape(8.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;Compartilhar perfil&quot;,&#10;                color = Color.White,&#10;                fontSize = 14.sp&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun EventTabs(&#10;    selectedTab: Int,&#10;    tabs: List&lt;String&gt;,&#10;    onTabSelected: (Int) -&gt; Unit&#10;) {&#10;    TabRow(&#10;        selectedTabIndex = selectedTab,&#10;        modifier = Modifier.fillMaxWidth(),&#10;        containerColor = Color.White,&#10;        contentColor = Primary,&#10;        indicator = { tabPositions -&gt;&#10;            TabRowDefaults.Indicator(&#10;                modifier = Modifier.tabIndicatorOffset(tabPositions[selectedTab]),&#10;                color = Primary&#10;            )&#10;        }&#10;    ) {&#10;        tabs.forEachIndexed { index, title -&gt;&#10;            Tab(&#10;                selected = selectedTab == index,&#10;                onClick = { onTabSelected(index) },&#10;                text = {&#10;                    Text(&#10;                        text = title,&#10;                        fontSize = 16.sp,&#10;                        fontWeight = if (selectedTab == index) FontWeight.Bold else FontWeight.Normal&#10;                    )&#10;                },&#10;                selectedContentColor = Primary,&#10;                unselectedContentColor = Color.Gray&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>